<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="./">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>PyCypher: Cypher Parser and Query Executor for Python documentation</title>
      <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="_static/css/theme.css?v=19f00094" />

  
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="_static/jquery.js?v=5d32c60e"></script>
        <script src="_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script src="_static/documentation_options.js?v=5929fcd5"></script>
        <script src="_static/doctools.js?v=9a2dae69"></script>
        <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="#" class="icon icon-home">
            PyCypher: Cypher Parser and Query Executor for Python
          </a>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1 current"><a class="current reference internal" href="#document-index">Home</a></li>
<li class="toctree-l1"><a class="reference internal" href="#document-api">API</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="#">PyCypher: Cypher Parser and Query Executor for Python</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="#" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">PyCypher: Cypher Parser and Query Executor for Python  documentation</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="pycypher-a-pythonic-cypher-query-builder">
<h1>PyCypher: A Pythonic Cypher Query Builder<a class="headerlink" href="#pycypher-a-pythonic-cypher-query-builder" title="Link to this heading"></a></h1>
<p><strong>PyCypher</strong> is a Python library for parsing and executing Cypher queries against arbitrary graph data.</p>
<section id="cypher-ast-generator-for-python">
<h2>Cypher AST Generator for Python<a class="headerlink" href="#cypher-ast-generator-for-python" title="Link to this heading"></a></h2>
<p>This is a <em>work in progress</em>, by which I mean, “ugly, but fixable.” It
is also woefully incomplete. It generates an abstract syntax tree for
Cypher statements that use only a subset of the language. That subset is
growing, but it’s still small.</p>
<p>Additionally, this package contains the beginning of a query engine that
is designed to accept Cypher queries and return results from arbitrary
graph structures in Python. This functionality is in a <em>very</em> early
state, and works only for trivial queries.</p>
<p>The hope is that this will be useful for building modules that can take
advantage of the Cypher query language, by eliminating the need to do
all the boring work of writing a parser and generating an AST.</p>
<section id="how-to-use-it">
<h3>How to use it<a class="headerlink" href="#how-to-use-it" title="Link to this heading"></a></h3>
<p>Don’t. But if you really want to, then:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">pycypher.parser</span><span class="w"> </span><span class="kn">import</span> <span class="n">CypherParser</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cypher</span> <span class="o">=</span> <span class="n">CypherParser</span><span class="p">(</span><span class="s2">&quot;MATCH (n:Thing) RETURN n.foo&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cypher</span><span class="o">.</span><span class="n">parsed</span><span class="o">.</span><span class="n">print_tree</span><span class="p">()</span>

<span class="go">Cypher</span>
<span class="go">└── Query</span>
<span class="go">    ├── Match</span>
<span class="go">    │   └── Node</span>
<span class="go">    │       └── NodeNameLabel</span>
<span class="go">    │           ├── n</span>
<span class="go">    │           └── Thing</span>
<span class="go">    └── Return</span>
<span class="go">        └── Projection</span>
<span class="go">            └── ObjectAttributeLookup</span>
<span class="go">                ├── n</span>
<span class="go">                └── foo</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">cypher</span><span class="o">.</span><span class="n">parsed</span><span class="p">)</span>
<span class="go">Cypher(Query(Match(Node(NodeNameLabel(n, Thing), None)), Return(Projection([ObjectAttributeLookup(n, foo)]))))</span>
</pre></div>
</div>
<p>If you want to understand what’s happening, what Python classes are
being built, etc., then you’ll have to use the source, Luke. Check out
the <code class="docutils literal notranslate"><span class="pre">__main__</span></code> function at the end of the <code class="docutils literal notranslate"><span class="pre">cypher.py</span></code> script. There
are no docs yet. Like I said, this is a <em>work in progress</em>.</p>
<p>In addition to parsing Cypher queries, there is the beginning of support
for querying your data with Cypher. It is very experimental.</p>
<p>The design of <code class="docutils literal notranslate"><span class="pre">pycypher</span></code>’s querying process requires a few simple
steps:</p>
<ul class="simple">
<li><p>First, you define individual <code class="docutils literal notranslate"><span class="pre">Fact</span></code> objects from your graph data;</p></li>
<li><p>then you put them all in a <code class="docutils literal notranslate"><span class="pre">FactCollection</span></code> object.</p></li>
<li><p>Instantiate a <code class="docutils literal notranslate"><span class="pre">CypherParser</span></code> object with your Cypher query;</p></li>
<li><p>finally, call <code class="docutils literal notranslate"><span class="pre">CypherParser.solutions</span></code> with your <code class="docutils literal notranslate"><span class="pre">FactCollection</span></code>,
which will return a list of dictionaries containing solutions to your
query.</p></li>
</ul>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1">################################</span>
<span class="c1">### Build FactCollection</span>
<span class="c1">################################</span>

<span class="n">fact1</span> <span class="o">=</span> <span class="n">FactNodeHasLabel</span><span class="p">(</span><span class="s2">&quot;1&quot;</span><span class="p">,</span> <span class="s2">&quot;Thing&quot;</span><span class="p">)</span>
<span class="n">fact2</span> <span class="o">=</span> <span class="n">FactNodeHasAttributeWithValue</span><span class="p">(</span><span class="s2">&quot;1&quot;</span><span class="p">,</span> <span class="s2">&quot;key&quot;</span><span class="p">,</span> <span class="n">Literal</span><span class="p">(</span><span class="s2">&quot;2&quot;</span><span class="p">))</span>
<span class="n">fact3</span> <span class="o">=</span> <span class="n">FactNodeRelatedToNode</span><span class="p">(</span><span class="s2">&quot;1&quot;</span><span class="p">,</span> <span class="s2">&quot;2&quot;</span><span class="p">,</span> <span class="s2">&quot;MyRelationship&quot;</span><span class="p">)</span>
<span class="n">fact4</span> <span class="o">=</span> <span class="n">FactNodeHasLabel</span><span class="p">(</span><span class="s2">&quot;2&quot;</span><span class="p">,</span> <span class="s2">&quot;OtherThing&quot;</span><span class="p">)</span>
<span class="n">fact5</span> <span class="o">=</span> <span class="n">FactNodeHasAttributeWithValue</span><span class="p">(</span><span class="s2">&quot;2&quot;</span><span class="p">,</span> <span class="s2">&quot;key&quot;</span><span class="p">,</span> <span class="n">Literal</span><span class="p">(</span><span class="mi">5</span><span class="p">))</span>

<span class="n">fact_collection</span> <span class="o">=</span> <span class="n">FactCollection</span><span class="p">([</span><span class="n">fact1</span><span class="p">,</span> <span class="n">fact2</span><span class="p">,</span> <span class="n">fact3</span><span class="p">,</span> <span class="n">fact4</span><span class="p">,</span> <span class="n">fact5</span><span class="p">])</span>

<span class="c1">###########################################</span>
<span class="c1">### Define Cypher Query</span>
<span class="c1">###########################################</span>

<span class="n">cypher_statement</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;MATCH (n:Thing </span><span class="si">{key: 2}</span><span class="s2">) RETURN n.key&quot;&quot;&quot;</span>

<span class="c1">###########################################</span>
<span class="c1">### Parse Cypher Query</span>
<span class="c1">###########################################</span>

<span class="n">parsed</span> <span class="o">=</span> <span class="n">CypherParser</span><span class="p">(</span><span class="n">cypher_statement</span><span class="p">)</span>
<span class="n">instances</span> <span class="o">=</span> <span class="n">parsed</span><span class="o">.</span><span class="n">solutions</span><span class="p">(</span><span class="n">fact_collection</span><span class="p">)</span>
<span class="n">rich</span><span class="o">.</span><span class="n">print</span><span class="p">(</span><span class="n">instances</span><span class="p">)</span>
</pre></div>
</div>
<p>which will return:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[{</span><span class="n">n</span><span class="p">:</span> <span class="mi">1</span><span class="p">}]</span>
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">n</span></code> is the node variable from your Cypher query. It says that
the node whose ID is <code class="docutils literal notranslate"><span class="pre">1</span></code> can be put in for the value of <code class="docutils literal notranslate"><span class="pre">n</span></code> in your
Cypher query. Alert readers will notice that the query actually asks for
an attribute of <code class="docutils literal notranslate"><span class="pre">n</span></code>, not the ID of <code class="docutils literal notranslate"><span class="pre">n</span></code> itself. I know; we haven’t
gotten there yet.</p>
<p>Why is it designed this way? The idea is that if you’ve got a graph-like
structure (say, a <code class="docutils literal notranslate"><span class="pre">networkx</span></code> graph), it would be very easy to walk the
graph and create a list of simple <code class="docutils literal notranslate"><span class="pre">Fact</span></code> objects. Those can be put in
a <code class="docutils literal notranslate"><span class="pre">FactCollection</span></code> and passed into your <code class="docutils literal notranslate"><span class="pre">CypherParser</span></code>. In other
words, the various <code class="docutils literal notranslate"><span class="pre">Fact</span></code> classes are there to provide a simple and
intuitive target to represent graph data. So long as you can get the
data into a <code class="docutils literal notranslate"><span class="pre">FactCollection</span></code>, you can query it. The next logical step
in developing this package is to provide out-of-the-box methods for
querying various graph data formats, probably starting with
<code class="docutils literal notranslate"><span class="pre">networkx</span></code>.</p>
</section>
<section id="under-the-hood">
<h3>Under the hood<a class="headerlink" href="#under-the-hood" title="Link to this heading"></a></h3>
<p>The package is simple, but complicated in the sense of “God, this is
tedious!”. It contains a grammar in the old style of Lex and Yacc, which
is processed by the <code class="docutils literal notranslate"><span class="pre">PLY</span></code> package. From there, an AST is generated
which is constructed from a set of classes representing the semantic
structure of the query (in contrast to a so-called “concrete” syntax
tree which literally represents only the exact syntax).</p>
<p>For querying your data with the help of the AST, this package treats
querying as a problem of constraint satisfaction over a finite domain.
The AST yields a set of constraints such as “There is a node named <code class="docutils literal notranslate"><span class="pre">n</span></code>
which has the label <code class="docutils literal notranslate"><span class="pre">Foo</span></code>”. The <code class="docutils literal notranslate"><span class="pre">FactCollection</span></code> object defines the
domain of the constraint satisfaction problem. When you ask for
solutions, a potentially large number of partial functions over the
finite domain is generated, which form the constraints. Then we apply a
backtracking constraint solver to get every set of assignments of
variables to the domain satisfying the constraints.</p>
</section>
<section id="installation">
<h3>Installation<a class="headerlink" href="#installation" title="Link to this heading"></a></h3>
<section id="mac-and-linux">
<h4>Mac and Linux<a class="headerlink" href="#mac-and-linux" title="Link to this heading"></a></h4>
<p>You’ll need to be able to run <code class="docutils literal notranslate"><span class="pre">uv</span></code> in order to use the <code class="docutils literal notranslate"><span class="pre">Makefile</span></code>.
To install <code class="docutils literal notranslate"><span class="pre">uv</span></code> on Linux or Mac:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>curl<span class="w"> </span>-LsSf<span class="w"> </span>https://astral.sh/uv/install.sh<span class="w"> </span><span class="p">|</span><span class="w"> </span>sh
</pre></div>
</div>
<p>If you don’t have <code class="docutils literal notranslate"><span class="pre">make</span></code> on your Mac, then you should:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>brew<span class="w"> </span>install<span class="w"> </span>make
</pre></div>
</div>
<p>And if you don’t have <code class="docutils literal notranslate"><span class="pre">brew</span></code>, then install it with:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>/bin/bash<span class="w"> </span>-c<span class="w"> </span><span class="s2">&quot;</span><span class="k">$(</span>curl<span class="w"> </span>-fsSL<span class="w"> </span>https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh<span class="k">)</span><span class="s2">&quot;</span>
</pre></div>
</div>
<p>If you’re running Linux without <code class="docutils literal notranslate"><span class="pre">make</span></code>, then follow the directions for
your distribution. For example, on Ubuntu, you can:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>sudo<span class="w"> </span>apt<span class="w"> </span>install<span class="w"> </span>make
</pre></div>
</div>
</section>
<section id="windows">
<h4>Windows<a class="headerlink" href="#windows" title="Link to this heading"></a></h4>
<p>On Windows, erase your hard drive, install Linux, and then follow the
directions above.</p>
</section>
</section>
<section id="setting-everything-up">
<h3>Setting everything up<a class="headerlink" href="#setting-everything-up" title="Link to this heading"></a></h3>
<p>To set up the virtual environment, install all the dependencies, install
the right version of Python, build the package, install it as an
editable project, run a bunch of unit tests, and build HTML
documentation, do:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>make<span class="w"> </span>all
</pre></div>
</div>
<p>To clean everything up, deleting the virtual environment, documentation,
and so on, do:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>make<span class="w"> </span>clean
</pre></div>
</div>
<p>You don’t <em>need</em> to use the <code class="docutils literal notranslate"><span class="pre">Makefile</span></code>, and therefore you don’t <em>need</em>
to have <code class="docutils literal notranslate"><span class="pre">uv</span></code> installed on your system. But that’s what all the cool
kids are using these days.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This project is very incomplete, but being actively developed.</p>
</div>
</section>
<section id="contents">
<h3>Contents<a class="headerlink" href="#contents" title="Link to this heading"></a></h3>
<div class="toctree-wrapper compound">
<span id="document-api"></span><section id="api">
<h4>API<a class="headerlink" href="#api" title="Link to this heading"></a></h4>
<div class="toctree-wrapper compound">
<span id="document-generated/pycypher"></span><section id="module-pycypher.cypher_parser">
<span id="parser"></span><h5>Parser<a class="headerlink" href="#module-pycypher.cypher_parser" title="Link to this heading"></a></h5>
<p>Main parser module.</p>
<p class="rubric">Functions</p>
<table class="autosummary longtable docutils align-default">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#pycypher.cypher_parser.CypherParser" title="pycypher.cypher_parser.CypherParser"><code class="xref py py-obj docutils literal notranslate"><span class="pre">CypherParser</span></code></a>(cypher_text)</p></td>
<td><p>The main class of the <code class="docutils literal notranslate"><span class="pre">pycypher</span></code> package.</p></td>
</tr>
</tbody>
</table>
<dl class="py class">
<dt class="sig sig-object py" id="pycypher.cypher_parser.CypherParser">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pycypher.cypher_parser.</span></span><span class="sig-name descname"><span class="pre">CypherParser</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cypher_text</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.13)"><span class="pre">str</span></a></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pycypher.cypher_parser.CypherParser" title="Link to this definition"></a></dt>
<dd><p>The main class of the <code class="docutils literal notranslate"><span class="pre">pycypher</span></code> package.</p>
<p>This class is responsible for parsing Cypher queries and
returning the solutions to those queries. It creates the
AST for the Cypher query and then generates a constraint
satisfaction problem which solves the query.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pycypher.cypher_parser.p_aggregation">
<span class="sig-prename descclassname"><span class="pre">pycypher.cypher_parser.</span></span><span class="sig-name descname"><span class="pre">p_aggregation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">p</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">YaccProduction</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pycypher.cypher_parser.p_aggregation" title="Link to this definition"></a></dt>
<dd><p>aggregation : collect
| DISTINCT aggregation</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pycypher.cypher_parser.p_alias">
<span class="sig-prename descclassname"><span class="pre">pycypher.cypher_parser.</span></span><span class="sig-name descname"><span class="pre">p_alias</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">p</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">YaccProduction</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pycypher.cypher_parser.p_alias" title="Link to this definition"></a></dt>
<dd><p>alias : WORD AS WORD
| object_attribute_lookup AS WORD
| aggregation AS WORD</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pycypher.cypher_parser.p_aliased_name">
<span class="sig-prename descclassname"><span class="pre">pycypher.cypher_parser.</span></span><span class="sig-name descname"><span class="pre">p_aliased_name</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">p</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">YaccProduction</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pycypher.cypher_parser.p_aliased_name" title="Link to this definition"></a></dt>
<dd><p>aliased_name : WORD</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pycypher.cypher_parser.p_binary_expression">
<span class="sig-prename descclassname"><span class="pre">pycypher.cypher_parser.</span></span><span class="sig-name descname"><span class="pre">p_binary_expression</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">p</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">YaccProduction</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pycypher.cypher_parser.p_binary_expression" title="Link to this definition"></a></dt>
<dd><p>binary_expression : object_attribute_lookup binary_function literal
| object_attribute_lookup binary_function object_attribute_lookup
| aliased_name binary_function literal
| literal binary_function literal</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pycypher.cypher_parser.p_binary_function">
<span class="sig-prename descclassname"><span class="pre">pycypher.cypher_parser.</span></span><span class="sig-name descname"><span class="pre">p_binary_function</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">p</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3/library/typing.html#typing.Tuple" title="(in Python v3.13)"><span class="pre">Tuple</span></a><span class="p"><span class="pre">[</span></span><span class="pre">YaccProduction</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.13)"><span class="pre">str</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pycypher.cypher_parser.p_binary_function" title="Link to this definition"></a></dt>
<dd><p>binary_function : ADDITION</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pycypher.cypher_parser.p_binary_operator">
<span class="sig-prename descclassname"><span class="pre">pycypher.cypher_parser.</span></span><span class="sig-name descname"><span class="pre">p_binary_operator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">p</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3/library/typing.html#typing.Tuple" title="(in Python v3.13)"><span class="pre">Tuple</span></a><span class="p"><span class="pre">[</span></span><span class="pre">YaccProduction</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.13)"><span class="pre">str</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pycypher.cypher_parser.p_binary_operator" title="Link to this definition"></a></dt>
<dd><p>binary_operator : EQUALS
| LESSTHAN
| GREATERTHAN
| OR
| AND</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pycypher.cypher_parser.p_collect">
<span class="sig-prename descclassname"><span class="pre">pycypher.cypher_parser.</span></span><span class="sig-name descname"><span class="pre">p_collect</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">p</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">YaccProduction</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pycypher.cypher_parser.p_collect" title="Link to this definition"></a></dt>
<dd><p>collect : COLLECT LPAREN object_attribute_lookup RPAREN</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pycypher.cypher_parser.p_cypher">
<span class="sig-prename descclassname"><span class="pre">pycypher.cypher_parser.</span></span><span class="sig-name descname"><span class="pre">p_cypher</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">p</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3/library/typing.html#typing.List" title="(in Python v3.13)"><span class="pre">List</span></a><span class="p"><span class="pre">[</span></span><a class="reference internal" href="index.html#pycypher.tree_mixin.TreeMixin" title="pycypher.tree_mixin.TreeMixin"><span class="pre">TreeMixin</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pycypher.cypher_parser.p_cypher" title="Link to this definition"></a></dt>
<dd><p>cypher : query</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pycypher.cypher_parser.p_float">
<span class="sig-prename descclassname"><span class="pre">pycypher.cypher_parser.</span></span><span class="sig-name descname"><span class="pre">p_float</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">p</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">YaccProduction</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pycypher.cypher_parser.p_float" title="Link to this definition"></a></dt>
<dd><p>float : FLOAT</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pycypher.cypher_parser.p_incomplete_relationship_chain">
<span class="sig-prename descclassname"><span class="pre">pycypher.cypher_parser.</span></span><span class="sig-name descname"><span class="pre">p_incomplete_relationship_chain</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">p</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">YaccProduction</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pycypher.cypher_parser.p_incomplete_relationship_chain" title="Link to this definition"></a></dt>
<dd><p>incomplete_relationship_chain : node left_right
| node right_left
| incomplete_relationship_chain node left_right
| incomplete_relationship_chain node right_left</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pycypher.cypher_parser.p_integer">
<span class="sig-prename descclassname"><span class="pre">pycypher.cypher_parser.</span></span><span class="sig-name descname"><span class="pre">p_integer</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">p</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">YaccProduction</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pycypher.cypher_parser.p_integer" title="Link to this definition"></a></dt>
<dd><p>integer : INTEGER</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pycypher.cypher_parser.p_left_right">
<span class="sig-prename descclassname"><span class="pre">pycypher.cypher_parser.</span></span><span class="sig-name descname"><span class="pre">p_left_right</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">p</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">YaccProduction</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pycypher.cypher_parser.p_left_right" title="Link to this definition"></a></dt>
<dd><p>left_right : DASH relationship DASH GREATERTHAN</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pycypher.cypher_parser.p_literal">
<span class="sig-prename descclassname"><span class="pre">pycypher.cypher_parser.</span></span><span class="sig-name descname"><span class="pre">p_literal</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">p</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">YaccProduction</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pycypher.cypher_parser.p_literal" title="Link to this definition"></a></dt>
<dd><p>literal : integer
| float
| STRING</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pycypher.cypher_parser.p_mapping_list">
<span class="sig-prename descclassname"><span class="pre">pycypher.cypher_parser.</span></span><span class="sig-name descname"><span class="pre">p_mapping_list</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">p</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3/library/typing.html#typing.List" title="(in Python v3.13)"><span class="pre">List</span></a><span class="p"><span class="pre">[</span></span><a class="reference internal" href="index.html#pycypher.tree_mixin.TreeMixin" title="pycypher.tree_mixin.TreeMixin"><span class="pre">TreeMixin</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pycypher.cypher_parser.p_mapping_list" title="Link to this definition"></a></dt>
<dd><p>mapping_list : WORD COLON literal
| mapping_list COMMA WORD COLON literal</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pycypher.cypher_parser.p_match_pattern">
<span class="sig-prename descclassname"><span class="pre">pycypher.cypher_parser.</span></span><span class="sig-name descname"><span class="pre">p_match_pattern</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">p</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">YaccProduction</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pycypher.cypher_parser.p_match_pattern" title="Link to this definition"></a></dt>
<dd><p>match_pattern : MATCH node
| MATCH relationship_chain_list
| MATCH relationship_chain_list with_clause
| MATCH relationship_chain_list where
| MATCH relationship_chain_list with_clause where
| MATCH node where
| MATCH node with_clause where</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pycypher.cypher_parser.p_name_label">
<span class="sig-prename descclassname"><span class="pre">pycypher.cypher_parser.</span></span><span class="sig-name descname"><span class="pre">p_name_label</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">p</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3/library/typing.html#typing.Tuple" title="(in Python v3.13)"><span class="pre">Tuple</span></a><span class="p"><span class="pre">[</span></span><span class="pre">YaccProduction</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.13)"><span class="pre">str</span></a><span class="p"><span class="pre">]</span></span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><a class="reference external" href="https://docs.python.org/3/library/typing.html#typing.Tuple" title="(in Python v3.13)"><span class="pre">Tuple</span></a><span class="p"><span class="pre">[</span></span><span class="pre">YaccProduction</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.13)"><span class="pre">str</span></a><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.13)"><span class="pre">str</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pycypher.cypher_parser.p_name_label" title="Link to this definition"></a></dt>
<dd><p>name_label : WORD
| WORD COLON WORD
| COLON WORD</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pycypher.cypher_parser.p_node">
<span class="sig-prename descclassname"><span class="pre">pycypher.cypher_parser.</span></span><span class="sig-name descname"><span class="pre">p_node</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">p</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">YaccProduction</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pycypher.cypher_parser.p_node" title="Link to this definition"></a></dt>
<dd><p>node : LPAREN name_label RPAREN
| LPAREN name_label LCURLY mapping_list RCURLY RPAREN
| LPAREN RPAREN
| LPAREN WORD RPAREN</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pycypher.cypher_parser.p_object_attribute_lookup">
<span class="sig-prename descclassname"><span class="pre">pycypher.cypher_parser.</span></span><span class="sig-name descname"><span class="pre">p_object_attribute_lookup</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">p</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">YaccProduction</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pycypher.cypher_parser.p_object_attribute_lookup" title="Link to this definition"></a></dt>
<dd><p>object_attribute_lookup : WORD DOT WORD
| WORD</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pycypher.cypher_parser.p_predicate">
<span class="sig-prename descclassname"><span class="pre">pycypher.cypher_parser.</span></span><span class="sig-name descname"><span class="pre">p_predicate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">p</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">YaccProduction</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pycypher.cypher_parser.p_predicate" title="Link to this definition"></a></dt>
<dd><p>predicate : object_attribute_lookup binary_operator literal
| object_attribute_lookup binary_operator object_attribute_lookup
| aliased_name binary_operator literal
| object_attribute_lookup binary_operator binary_expression</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pycypher.cypher_parser.p_projection">
<span class="sig-prename descclassname"><span class="pre">pycypher.cypher_parser.</span></span><span class="sig-name descname"><span class="pre">p_projection</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">p</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">YaccProduction</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pycypher.cypher_parser.p_projection" title="Link to this definition"></a></dt>
<dd><p>projection : object_attribute_lookup
| alias
| projection COMMA alias
| projection COMMA object_attribute_lookup</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pycypher.cypher_parser.p_query">
<span class="sig-prename descclassname"><span class="pre">pycypher.cypher_parser.</span></span><span class="sig-name descname"><span class="pre">p_query</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">p</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3/library/typing.html#typing.Tuple" title="(in Python v3.13)"><span class="pre">Tuple</span></a><span class="p"><span class="pre">[</span></span><span class="pre">YaccProduction</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference internal" href="index.html#pycypher.node_classes.Match" title="pycypher.node_classes.Match"><span class="pre">Match</span></a><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference internal" href="index.html#pycypher.node_classes.Return" title="pycypher.node_classes.Return"><span class="pre">Return</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pycypher.cypher_parser.p_query" title="Link to this definition"></a></dt>
<dd><p>query : match_pattern return</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pycypher.cypher_parser.p_relationship">
<span class="sig-prename descclassname"><span class="pre">pycypher.cypher_parser.</span></span><span class="sig-name descname"><span class="pre">p_relationship</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">p</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">YaccProduction</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pycypher.cypher_parser.p_relationship" title="Link to this definition"></a></dt>
<dd><p>relationship : LSQUARE WORD RSQUARE
| LSQUARE name_label RSQUARE</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pycypher.cypher_parser.p_relationship_chain">
<span class="sig-prename descclassname"><span class="pre">pycypher.cypher_parser.</span></span><span class="sig-name descname"><span class="pre">p_relationship_chain</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">p</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">YaccProduction</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pycypher.cypher_parser.p_relationship_chain" title="Link to this definition"></a></dt>
<dd><p>relationship_chain : incomplete_relationship_chain node</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pycypher.cypher_parser.p_relationship_chain_list">
<span class="sig-prename descclassname"><span class="pre">pycypher.cypher_parser.</span></span><span class="sig-name descname"><span class="pre">p_relationship_chain_list</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">p</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">YaccProduction</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pycypher.cypher_parser.p_relationship_chain_list" title="Link to this definition"></a></dt>
<dd><p>relationship_chain_list : relationship_chain
| relationship_chain_list COMMA relationship_chain</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pycypher.cypher_parser.p_return">
<span class="sig-prename descclassname"><span class="pre">pycypher.cypher_parser.</span></span><span class="sig-name descname"><span class="pre">p_return</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">p</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">YaccProduction</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pycypher.cypher_parser.p_return" title="Link to this definition"></a></dt>
<dd><p>return : RETURN projection</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pycypher.cypher_parser.p_right_left">
<span class="sig-prename descclassname"><span class="pre">pycypher.cypher_parser.</span></span><span class="sig-name descname"><span class="pre">p_right_left</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">p</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">YaccProduction</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pycypher.cypher_parser.p_right_left" title="Link to this definition"></a></dt>
<dd><p>right_left : LESSTHAN DASH relationship DASH</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pycypher.cypher_parser.p_string">
<span class="sig-prename descclassname"><span class="pre">pycypher.cypher_parser.</span></span><span class="sig-name descname"><span class="pre">p_string</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">p</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">YaccProduction</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pycypher.cypher_parser.p_string" title="Link to this definition"></a></dt>
<dd><p>string : STRING</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pycypher.cypher_parser.p_where">
<span class="sig-prename descclassname"><span class="pre">pycypher.cypher_parser.</span></span><span class="sig-name descname"><span class="pre">p_where</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">p</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">YaccProduction</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pycypher.cypher_parser.p_where" title="Link to this definition"></a></dt>
<dd><p>where : WHERE predicate
| where COMMA predicate</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pycypher.cypher_parser.p_with_as_series">
<span class="sig-prename descclassname"><span class="pre">pycypher.cypher_parser.</span></span><span class="sig-name descname"><span class="pre">p_with_as_series</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">p</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">YaccProduction</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pycypher.cypher_parser.p_with_as_series" title="Link to this definition"></a></dt>
<dd><p>with_as_series : alias
| with_as_series COMMA alias</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pycypher.cypher_parser.p_with_clause">
<span class="sig-prename descclassname"><span class="pre">pycypher.cypher_parser.</span></span><span class="sig-name descname"><span class="pre">p_with_clause</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">p</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">YaccProduction</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pycypher.cypher_parser.p_with_clause" title="Link to this definition"></a></dt>
<dd><p>with_clause : WITH with_as_series</p>
</dd></dl>

</section>
<span id="document-generated/pycypher.cypher_lexer"></span><section id="module-pycypher.cypher_lexer">
<span id="lexer"></span><h5>Lexer<a class="headerlink" href="#module-pycypher.cypher_lexer" title="Link to this heading"></a></h5>
<p>This uses the <code class="docutils literal notranslate"><span class="pre">PLY</span></code> package to define the lexer. “Lexing” is the process of
breaking a string into tokens. This is the first step in the process of
parsing a language.</p>
<p>The lexer itself is defined at the end of the file (<code class="docutils literal notranslate"><span class="pre">lexer</span> <span class="pre">=</span> <span class="pre">lex.lex()</span></code>). It is
imported by the parser, which is defined in the <code class="docutils literal notranslate"><span class="pre">__init__.py</span></code> file.</p>
<p class="rubric">Functions</p>
<table class="autosummary longtable docutils align-default">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#pycypher.cypher_lexer.t_WORD" title="pycypher.cypher_lexer.t_WORD"><code class="xref py py-obj docutils literal notranslate"><span class="pre">t_WORD</span></code></a>(t)</p></td>
<td><p>[<a href="#id1"><span class="problematic" id="id2">a-zA-Z_</span></a>][a-zA-Z_0-9]*</p></td>
</tr>
</tbody>
</table>
<dl class="py function">
<dt class="sig sig-object py" id="pycypher.cypher_lexer.t_STRING">
<span class="sig-prename descclassname"><span class="pre">pycypher.cypher_lexer.</span></span><span class="sig-name descname"><span class="pre">t_STRING</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">t</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pycypher.cypher_lexer.t_STRING" title="Link to this definition"></a></dt>
<dd><p>“[^”]*”</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pycypher.cypher_lexer.t_WORD">
<span class="sig-prename descclassname"><span class="pre">pycypher.cypher_lexer.</span></span><span class="sig-name descname"><span class="pre">t_WORD</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">t</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">LexToken</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference external" href="https://docs.python.org/3/library/typing.html#typing.Any" title="(in Python v3.13)"><span class="pre">Any</span></a></span></span><a class="headerlink" href="#pycypher.cypher_lexer.t_WORD" title="Link to this definition"></a></dt>
<dd><p>[<a href="#id3"><span class="problematic" id="id4">a-zA-Z_</span></a>][a-zA-Z_0-9]*</p>
</dd></dl>

</section>
<span id="document-generated/pycypher.exceptions"></span><section id="module-pycypher.exceptions">
<span id="exceptions"></span><h5>Exceptions<a class="headerlink" href="#module-pycypher.exceptions" title="Link to this heading"></a></h5>
<p>Custom exceptions for PyCypher</p>
<p class="rubric">Classes</p>
<table class="autosummary longtable docutils align-default">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#pycypher.exceptions.CypherParsingError" title="pycypher.exceptions.CypherParsingError"><code class="xref py py-obj docutils literal notranslate"><span class="pre">CypherParsingError</span></code></a></p></td>
<td><p>To be thrown when the <cite>CypherParser</cite> cannot parse the expression at all.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#pycypher.exceptions.UnexpectedCypherStructureError" title="pycypher.exceptions.UnexpectedCypherStructureError"><code class="xref py py-obj docutils literal notranslate"><span class="pre">UnexpectedCypherStructureError</span></code></a></p></td>
<td><p>To be thrown when the <cite>CypherParser</cite> can parse the expression, but it has an unexpected structure.</p></td>
</tr>
</tbody>
</table>
<dl class="py exception">
<dt class="sig sig-object py" id="pycypher.exceptions.CypherParsingError">
<em class="property"><span class="pre">exception</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pycypher.exceptions.</span></span><span class="sig-name descname"><span class="pre">CypherParsingError</span></span><a class="headerlink" href="#pycypher.exceptions.CypherParsingError" title="Link to this definition"></a></dt>
<dd><p>To be thrown when the <cite>CypherParser</cite> cannot parse the expression at all.</p>
</dd></dl>

<dl class="py exception">
<dt class="sig sig-object py" id="pycypher.exceptions.UnexpectedCypherStructureError">
<em class="property"><span class="pre">exception</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pycypher.exceptions.</span></span><span class="sig-name descname"><span class="pre">UnexpectedCypherStructureError</span></span><a class="headerlink" href="#pycypher.exceptions.UnexpectedCypherStructureError" title="Link to this definition"></a></dt>
<dd><p>To be thrown when the <cite>CypherParser</cite> can parse the expression, but it has an unexpected structure.</p>
</dd></dl>

<dl class="py exception">
<dt class="sig sig-object py" id="pycypher.exceptions.WrongCypherTypeError">
<em class="property"><span class="pre">exception</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pycypher.exceptions.</span></span><span class="sig-name descname"><span class="pre">WrongCypherTypeError</span></span><a class="headerlink" href="#pycypher.exceptions.WrongCypherTypeError" title="Link to this definition"></a></dt>
<dd><p>To be thrown when the <cite>CypherParser</cite> can parse the expression, but it has an unexpected type.</p>
</dd></dl>

</section>
<span id="document-generated/pycypher.fact"></span><section id="module-pycypher.fact">
<span id="facts"></span><h5>Facts<a class="headerlink" href="#module-pycypher.fact" title="Link to this heading"></a></h5>
<p>Facts are simple atomic statements that have a truth value.</p>
<p class="rubric">Classes</p>
<table class="autosummary longtable docutils align-default">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#pycypher.fact.AtomicFact" title="pycypher.fact.AtomicFact"><code class="xref py py-obj docutils literal notranslate"><span class="pre">AtomicFact</span></code></a>()</p></td>
<td><p>Abstract base class for specific types of <cite>Fact</cite>.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#pycypher.fact.FactCollection" title="pycypher.fact.FactCollection"><code class="xref py py-obj docutils literal notranslate"><span class="pre">FactCollection</span></code></a>(facts)</p></td>
<td><p>A collection of AtomicFact objects with various utility methods for querying and manipulating the facts.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#pycypher.fact.FactNodeHasAttributeWithValue" title="pycypher.fact.FactNodeHasAttributeWithValue"><code class="xref py py-obj docutils literal notranslate"><span class="pre">FactNodeHasAttributeWithValue</span></code></a>(node_id, ...)</p></td>
<td><p>Represents a fact that a node has a specific attribute with a given value.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#pycypher.fact.FactNodeHasLabel" title="pycypher.fact.FactNodeHasLabel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">FactNodeHasLabel</span></code></a>(node_id, node_label)</p></td>
<td><p>Represents a fact that a node has a specific label.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#pycypher.fact.FactNodeRelatedToNode" title="pycypher.fact.FactNodeRelatedToNode"><code class="xref py py-obj docutils literal notranslate"><span class="pre">FactNodeRelatedToNode</span></code></a>(node1_id, node2_id, ...)</p></td>
<td><p>Represents a fact that one node is related to another node with a specific relationship label.</p></td>
</tr>
</tbody>
</table>
<dl class="py class">
<dt class="sig sig-object py" id="pycypher.fact.AtomicFact">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pycypher.fact.</span></span><span class="sig-name descname"><span class="pre">AtomicFact</span></span><a class="headerlink" href="#pycypher.fact.AtomicFact" title="Link to this definition"></a></dt>
<dd><p>Abstract base class for specific types of <cite>Fact</cite>.</p>
<p>This class serves as a base for creating various types of facts in the system.
It is intended to be subclassed and not used directly.</p>
<dl class="simple">
<dt>Attributes:</dt><dd><p>None</p>
</dd>
<dt>Methods:</dt><dd><p>None</p>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pycypher.fact.FactCollection">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pycypher.fact.</span></span><span class="sig-name descname"><span class="pre">FactCollection</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">facts</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3/library/typing.html#typing.List" title="(in Python v3.13)"><span class="pre">List</span></a><span class="p"><span class="pre">[</span></span><a class="reference internal" href="index.html#pycypher.fact.AtomicFact" title="pycypher.fact.AtomicFact"><span class="pre">AtomicFact</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pycypher.fact.FactCollection" title="Link to this definition"></a></dt>
<dd><p>A collection of AtomicFact objects with various utility methods for querying and manipulating the facts.</p>
<dl>
<dt>Attributes:</dt><dd><p>facts (List[AtomicFact]): A list of AtomicFact objects.</p>
</dd>
<dt>Methods:</dt><dd><dl>
<dt>__iter__() -&gt; Generator[AtomicFact]:</dt><dd><p>Yields each fact in the collection.</p>
</dd>
<dt>__repr__() -&gt; str:</dt><dd><p>Returns a string representation of the FactCollection.</p>
</dd>
<dt>__getitem__(index: int) -&gt; AtomicFact:</dt><dd><p>Returns the fact at the specified index.</p>
</dd>
<dt>__setitem__(index: int, value: AtomicFact):</dt><dd><p>Sets the fact at the specified index to the given value.</p>
</dd>
<dt>__delitem__(index: int):</dt><dd><p>Deletes the fact at the specified index.</p>
</dd>
<dt>__len__() -&gt; int:</dt><dd><p>Returns the number of facts in the collection.</p>
</dd>
<dt>insert(index: int, value: AtomicFact):</dt><dd><p>Inserts a fact at the specified index.</p>
</dd>
<dt>relationship_has_source_node_facts() -&gt; Generator[FactRelationshipHasSourceNode]:</dt><dd><p>Yields facts that are instances of FactRelationshipHasSourceNode.</p>
</dd>
<dt>relationship_has_target_node_facts() -&gt; Generator[FactRelationshipHasTargetNode]:</dt><dd><p>Yields facts that are instances of FactRelationshipHasTargetNode.</p>
</dd>
<dt>node_has_label_facts() -&gt; Generator[FactNodeHasLabel]:</dt><dd><p>Yields facts that are instances of FactNodeHasLabel.</p>
</dd>
<dt>node_has_attribute_with_value_facts() -&gt; Generator[FactNodeHasAttributeWithValue]:</dt><dd><p>Yields facts that are instances of FactNodeHasAttributeWithValue.</p>
</dd>
<dt>relationship_has_attribute_with_value_facts() -&gt; Generator[FactRelationshipHasAttributeWithValue]:</dt><dd><p>Yields facts that are instances of FactRelationshipHasAttributeWithValue.</p>
</dd>
<dt>query(query: Query) -&gt; Any:</dt><dd><p>Executes a query on the collection and returns the result.
Raises:</p>
<blockquote>
<div><p>ValueError: If the query cannot be resolved or if multiple values are found for a QueryValueOfNodeAttribute.
NotImplementedError: If the query type is unknown.</p>
</div></blockquote>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="pycypher.fact.FactCollection.insert">
<span class="sig-name descname"><span class="pre">insert</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">index</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.13)"><span class="pre">int</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">value</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="index.html#pycypher.fact.AtomicFact" title="pycypher.fact.AtomicFact"><span class="pre">AtomicFact</span></a></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pycypher.fact.FactCollection.insert" title="Link to this definition"></a></dt>
<dd><p>Insert an AtomicFact into the facts list at the specified index.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>index (int): The position at which to insert the value.
value (AtomicFact): The AtomicFact object to be inserted.</p>
</dd>
<dt>Returns:</dt><dd><p>None</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pycypher.fact.FactCollection.node_has_attribute_with_value_facts">
<span class="sig-name descname"><span class="pre">node_has_attribute_with_value_facts</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pycypher.fact.FactCollection.node_has_attribute_with_value_facts" title="Link to this definition"></a></dt>
<dd><p>Generator method that yields facts of type FactNodeHasAttributeWithValue.</p>
<p>Iterates over the list of facts and yields each fact that is an instance
of FactNodeHasAttributeWithValue.</p>
<dl class="simple">
<dt>Yields:</dt><dd><p>FactNodeHasAttributeWithValue: Facts that are instances of FactNodeHasAttributeWithValue.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pycypher.fact.FactCollection.node_has_label_facts">
<span class="sig-name descname"><span class="pre">node_has_label_facts</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pycypher.fact.FactCollection.node_has_label_facts" title="Link to this definition"></a></dt>
<dd><p>Generator function that yields facts of type <cite>FactNodeHasLabel</cite>.</p>
<p>Iterates over the <cite>facts</cite> attribute and yields each fact that is an instance
of <cite>FactNodeHasLabel</cite>.</p>
<dl class="simple">
<dt>Yields:</dt><dd><p>FactNodeHasLabel: Facts that are instances of <cite>FactNodeHasLabel</cite>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pycypher.fact.FactCollection.query">
<span class="sig-name descname"><span class="pre">query</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">query</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Query</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference external" href="https://docs.python.org/3/library/typing.html#typing.Any" title="(in Python v3.13)"><span class="pre">Any</span></a></span></span><a class="headerlink" href="#pycypher.fact.FactCollection.query" title="Link to this definition"></a></dt>
<dd><p>Executes a query to retrieve information based on the type of the query.</p>
<dl>
<dt>Args:</dt><dd><p>query (Query): The query object containing the parameters for the query.</p>
</dd>
<dt>Returns:</dt><dd><p>Any: The result of the query. The type of the result depends on the query type.</p>
</dd>
<dt>Raises:</dt><dd><dl class="simple">
<dt>ValueError: If the query is of type QueryValueOfNodeAttribute and no matching facts are found,</dt><dd><p>or if multiple matching facts are found, or if an unknown error occurs.</p>
</dd>
</dl>
<p>NotImplementedError: If the query type is not recognized.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pycypher.fact.FactCollection.relationship_has_attribute_with_value_facts">
<span class="sig-name descname"><span class="pre">relationship_has_attribute_with_value_facts</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pycypher.fact.FactCollection.relationship_has_attribute_with_value_facts" title="Link to this definition"></a></dt>
<dd><p>Generator function that yields facts of type FactRelationshipHasAttributeWithValue.</p>
<p>Iterates over the <cite>facts</cite> attribute and yields each fact that is an instance of
FactRelationshipHasAttributeWithValue.</p>
<dl class="simple">
<dt>Yields:</dt><dd><p>FactRelationshipHasAttributeWithValue: Facts that are instances of FactRelationshipHasAttributeWithValue.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pycypher.fact.FactCollection.relationship_has_source_node_facts">
<span class="sig-name descname"><span class="pre">relationship_has_source_node_facts</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pycypher.fact.FactCollection.relationship_has_source_node_facts" title="Link to this definition"></a></dt>
<dd><p>Generator method that yields facts of type FactRelationshipHasSourceNode.</p>
<p>This method iterates over the <cite>facts</cite> attribute of the instance and yields
each fact that is an instance of the FactRelationshipHasSourceNode class.</p>
<dl class="simple">
<dt>Yields:</dt><dd><p>FactRelationshipHasSourceNode: Facts that are instances of FactRelationshipHasSourceNode.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pycypher.fact.FactCollection.relationship_has_target_node_facts">
<span class="sig-name descname"><span class="pre">relationship_has_target_node_facts</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pycypher.fact.FactCollection.relationship_has_target_node_facts" title="Link to this definition"></a></dt>
<dd><p>Generator method that yields facts of type FactRelationshipHasTargetNode.</p>
<p>Iterates over the <cite>facts</cite> attribute of the instance and yields each fact
that is an instance of FactRelationshipHasTargetNode.</p>
<dl class="simple">
<dt>Yields:</dt><dd><p>FactRelationshipHasTargetNode: Facts that are instances of FactRelationshipHasTargetNode.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pycypher.fact.FactNodeHasAttributeWithValue">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pycypher.fact.</span></span><span class="sig-name descname"><span class="pre">FactNodeHasAttributeWithValue</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">node_id</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.13)"><span class="pre">str</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">attribute</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.13)"><span class="pre">str</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">value</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3/library/typing.html#typing.Any" title="(in Python v3.13)"><span class="pre">Any</span></a></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pycypher.fact.FactNodeHasAttributeWithValue" title="Link to this definition"></a></dt>
<dd><p>Represents a fact that a node has a specific attribute with a given value.</p>
<dl class="simple">
<dt>Attributes:</dt><dd><p>node_id (str): The identifier of the node.
attribute (str): The attribute of the node.
value (Any): The value of the attribute.</p>
</dd>
<dt>Methods:</dt><dd><p>__repr__(): Returns a string representation of the fact.
__eq__(other: Any): Checks equality between this fact and another fact.</p>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pycypher.fact.FactNodeHasLabel">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pycypher.fact.</span></span><span class="sig-name descname"><span class="pre">FactNodeHasLabel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">node_id</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.13)"><span class="pre">str</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">node_label</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.13)"><span class="pre">str</span></a></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pycypher.fact.FactNodeHasLabel" title="Link to this definition"></a></dt>
<dd><p>Represents a fact that a node has a specific label.</p>
<dl class="simple">
<dt>Attributes:</dt><dd><p>node_id (str): The ID of the node.
label (str): The label of the node.</p>
</dd>
<dt>Methods:</dt><dd><p>__repr__(): Returns a string representation of the FactNodeHasLabel instance.
__eq__(other: Any): Checks equality between this instance and another FactNodeHasLabel instance.</p>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pycypher.fact.FactNodeRelatedToNode">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pycypher.fact.</span></span><span class="sig-name descname"><span class="pre">FactNodeRelatedToNode</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">node1_id</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.13)"><span class="pre">str</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">node2_id</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.13)"><span class="pre">str</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">relationship_label</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.13)"><span class="pre">str</span></a></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pycypher.fact.FactNodeRelatedToNode" title="Link to this definition"></a></dt>
<dd><p>Represents a fact that one node is related to another node with a specific relationship label.</p>
<dl class="simple">
<dt>Attributes:</dt><dd><p>node1_id (str): The ID of the first node.
node2_id (str): The ID of the second node.
relationship_label (str): The label of the relationship between the two nodes.</p>
</dd>
<dt>Methods:</dt><dd><p>__repr__() -&gt; str: Returns a string representation of the fact.
__eq__(other: Any) -&gt; bool: Checks if this fact is equal to another fact.</p>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pycypher.fact.FactRelationshipHasAttributeWithValue">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pycypher.fact.</span></span><span class="sig-name descname"><span class="pre">FactRelationshipHasAttributeWithValue</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">relationship_id</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.13)"><span class="pre">str</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">attribute</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.13)"><span class="pre">str</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">value</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3/library/typing.html#typing.Any" title="(in Python v3.13)"><span class="pre">Any</span></a></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pycypher.fact.FactRelationshipHasAttributeWithValue" title="Link to this definition"></a></dt>
<dd><p>Represents a fact that a relationship has a specific attribute with a given value.</p>
<dl class="simple">
<dt>Attributes:</dt><dd><p>relationship_id (str): The ID of the relationship.
attribute (str): The attribute of the relationship.
value (Any): The value of the attribute.</p>
</dd>
<dt>Args:</dt><dd><p>relationship_id (str): The ID of the relationship.
attribute (str): The attribute of the relationship.
value (Any): The value of the attribute.</p>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pycypher.fact.FactRelationshipHasLabel">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pycypher.fact.</span></span><span class="sig-name descname"><span class="pre">FactRelationshipHasLabel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">relationship_id</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.13)"><span class="pre">str</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">relationship_label</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.13)"><span class="pre">str</span></a></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pycypher.fact.FactRelationshipHasLabel" title="Link to this definition"></a></dt>
<dd><p>Represents a fact that a relationship has a specific label.</p>
<dl class="simple">
<dt>Attributes:</dt><dd><p>relationship_id (str): The ID of the relationship.
relationship_label (str): The label of the relationship.</p>
</dd>
<dt>Methods:</dt><dd><p>__repr__(): Returns a string representation of the fact.
__eq__(other: Any) -&gt; bool: Checks equality between this fact and another.</p>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pycypher.fact.FactRelationshipHasSourceNode">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pycypher.fact.</span></span><span class="sig-name descname"><span class="pre">FactRelationshipHasSourceNode</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">relationship_id</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.13)"><span class="pre">str</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">source_node_id</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.13)"><span class="pre">str</span></a></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pycypher.fact.FactRelationshipHasSourceNode" title="Link to this definition"></a></dt>
<dd><p>Represents a fact that a relationship has a source node.</p>
<dl class="simple">
<dt>Attributes:</dt><dd><p>relationship_id (str): The ID of the relationship.
source_node_id (str): The ID of the source node.</p>
</dd>
<dt>Methods:</dt><dd><p>__repr__(): Returns a string representation of the FactRelationshipHasSourceNode instance.
__eq__(other: Any): Checks equality between this instance and another FactRelationshipHasSourceNode instance.</p>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pycypher.fact.FactRelationshipHasTargetNode">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pycypher.fact.</span></span><span class="sig-name descname"><span class="pre">FactRelationshipHasTargetNode</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">relationship_id</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.13)"><span class="pre">str</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">target_node_id</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.13)"><span class="pre">str</span></a></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pycypher.fact.FactRelationshipHasTargetNode" title="Link to this definition"></a></dt>
<dd><p>Represents a fact that a relationship has a target node.</p>
<dl class="simple">
<dt>Attributes:</dt><dd><p>relationship_id (str): The ID of the relationship.
target_node_id (str): The ID of the target node.</p>
</dd>
<dt>Methods:</dt><dd><dl class="simple">
<dt>__repr__() -&gt; str:</dt><dd><p>Returns a string representation of the FactRelationshipHasTargetNode instance.</p>
</dd>
<dt>__eq__(other: Any) -&gt; bool:</dt><dd><p>Checks if this instance is equal to another instance of FactRelationshipHasTargetNode.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</section>
<span id="document-generated/pycypher.logger"></span><section id="module-pycypher.logger">
<span id="logger"></span><h5>Logger<a class="headerlink" href="#module-pycypher.logger" title="Link to this heading"></a></h5>
</section>
<span id="document-generated/pycypher.node_classes"></span><section id="module-pycypher.node_classes">
<span id="ast-node-classes"></span><h5>AST Node Classes<a class="headerlink" href="#module-pycypher.node_classes" title="Link to this heading"></a></h5>
<p>This module defines various classes representing nodes and expressions in an
Abstract Syntax Tree (AST) for Cypher queries.</p>
<p>The classes include functionality for evaluating expressions, generating tree
representations, and handling constraints.</p>
<p>Classes:</p>
<ul class="simple">
<li><p><strong>Evaluable</strong>: Abstract base class representing an evaluable entity.</p></li>
<li><p><strong>Cypher</strong>: The root node of the AST for Cypher queries.</p></li>
<li><p><strong>Aggregation</strong>: Represents an aggregation operation that turns a list into a singleton.</p></li>
<li><p><strong>Collection</strong>: Represents a list of values.</p></li>
<li><p><strong>Distinct</strong>: Represents the DISTINCT keyword.</p></li>
<li><p><strong>Size</strong>: Represents the SIZE keyword.</p></li>
<li><p><strong>Collect</strong>: Represents the COLLECT keyword.</p></li>
<li><p><strong>Query</strong>: Represents the entire query.</p></li>
<li><p><strong>Predicate</strong>: Represents a unary or binary expression with a definite truth value.</p></li>
<li><p><strong>BinaryBoolean</strong>: Superclass for the And and Or connective classes.</p></li>
<li><p><strong>AliasedName</strong>: Represents a name that has been aliased with an AS statement.</p></li>
<li><p><strong>Equals</strong>: Represents the binary infix operator for equality.</p></li>
<li><p><strong>LessThan</strong>: Represents the binary infix operator for less than.</p></li>
<li><p><strong>GreaterThan</strong>: Represents the binary infix operator for greater than.</p></li>
<li><p><strong>Subtraction</strong>: Represents the binary infix operator for subtraction.</p></li>
<li><p><strong>Multiplication</strong>: Represents the binary infix operator for multiplication.</p></li>
<li><p><strong>Division</strong>: Represents the binary infix operator for division.</p></li>
<li><p><strong>ObjectAttributeLookup</strong>: Represents the value of an attribute of a node or relationship.</p></li>
<li><p><strong>Alias</strong>: Represents use of an AS statement in the query.</p></li>
<li><p><strong>ObjectAsSeries</strong>: Represents a series of object attribute lookups.</p></li>
<li><p><strong>WithClause</strong>: Represents the WITH clause of the query.</p></li>
<li><p><strong>Match</strong>: Represents the MATCH clause of the query.</p></li>
<li><p><strong>Return</strong>: Represents the RETURN clause of the query.</p></li>
<li><p>Projection: Represents a node variable followed by an attribute or another evaluable expression.</p></li>
<li><p><strong>NodeNameLabel</strong>: Represents a node name, optionally followed by a label.</p></li>
<li><p><strong>Node</strong>: Represents a node in the graph.</p></li>
<li><p><strong>Relationship</strong>: Represents a relationship in the graph.</p></li>
<li><p><strong>Mapping</strong>: Represents a dictionary of key-value pairs.</p></li>
<li><p><strong>MappingSet</strong>: Represents a list of mappings.</p></li>
<li><p><strong>MatchList</strong>: Represents a container for a list of Match objects.</p></li>
<li><p><strong>RelationshipLeftRight</strong>: Represents a relationship with the arrow pointing from left to right.</p></li>
<li><p><strong>RelationshipRightLeft</strong>: Represents a relationship with the arrow pointing from right to left.</p></li>
<li><p><strong>RelationshipChain</strong>: Represents several relationship nodes chained together.</p></li>
<li><p><strong>Where</strong>: Represents the WHERE clause of the query.</p></li>
<li><p><strong>And</strong>: Represents the logical AND connective.</p></li>
<li><p><strong>Or</strong>: Represents the logical OR connective.</p></li>
<li><p><strong>Not</strong>: Represents the logical NOT connective.</p></li>
<li><p><strong>RelationshipChainList</strong>: Represents a container for a list of relationship chains.</p></li>
<li><p><strong>Addition</strong>: Represents the binary infix operator for addition.</p></li>
<li><p><strong>Literal</strong>: Represents a container for a value.</p></li>
</ul>
<p class="rubric">Classes</p>
<table class="autosummary longtable docutils align-default">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#pycypher.node_classes.Alias" title="pycypher.node_classes.Alias"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Alias</span></code></a>(reference, alias)</p></td>
<td><p>Represents an alias for a reference in a tree structure.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#pycypher.node_classes.And" title="pycypher.node_classes.And"><code class="xref py py-obj docutils literal notranslate"><span class="pre">And</span></code></a>(left_side, right_side)</p></td>
<td><p>Represents a logical AND operation between two boolean expressions.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#pycypher.node_classes.BinaryBoolean" title="pycypher.node_classes.BinaryBoolean"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BinaryBoolean</span></code></a>(left_side, right_side)</p></td>
<td><p>A class representing a binary boolean operation in a predicate tree.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#pycypher.node_classes.Cypher" title="pycypher.node_classes.Cypher"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Cypher</span></code></a>(cypher)</p></td>
<td><p>The root node of the Abstract Syntax Tree (AST) for Cypher queries.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#pycypher.node_classes.Equals" title="pycypher.node_classes.Equals"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Equals</span></code></a>(left_side, right_side)</p></td>
<td><p>Binary infix operator for equality.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#pycypher.node_classes.GreaterThan" title="pycypher.node_classes.GreaterThan"><code class="xref py py-obj docutils literal notranslate"><span class="pre">GreaterThan</span></code></a>(left_side, right_side)</p></td>
<td><p>Binary infix operator for greater than.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#pycypher.node_classes.LessThan" title="pycypher.node_classes.LessThan"><code class="xref py py-obj docutils literal notranslate"><span class="pre">LessThan</span></code></a>(left_side, right_side)</p></td>
<td><p>Binary infix operator for less than.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#pycypher.node_classes.Literal" title="pycypher.node_classes.Literal"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Literal</span></code></a>(value)</p></td>
<td><p>A class representing a literal value in a tree structure.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#pycypher.node_classes.Mapping" title="pycypher.node_classes.Mapping"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Mapping</span></code></a>(key, value)</p></td>
<td><p>Mappings are dictionaries of key-value pairs.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#pycypher.node_classes.MappingSet" title="pycypher.node_classes.MappingSet"><code class="xref py py-obj docutils literal notranslate"><span class="pre">MappingSet</span></code></a>(mappings)</p></td>
<td><p>A list of mappings.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#pycypher.node_classes.Match" title="pycypher.node_classes.Match"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Match</span></code></a>(pattern[, where, with_clause, constraints])</p></td>
<td><p>Represents a MATCH clause in a Cypher query. Attributes:     pattern (TreeMixin): The pattern to match in the query. where (Optional[TreeMixin]): An optional WHERE clause to filter the results. with_clause (Optional[TreeMixin]): An optional WITH clause to chain queries. constraints (Optional[List[Constraint]]): A list of constraints to apply to the match. Methods:     __repr__() -&gt; str:         Returns a string representation of the Match object. gather_constraints() -&gt; None:         Gathers all the Constraint objects from inside the Match clause. tree() -&gt; Tree:         Constructs and returns a tree representation of the Match clause. children() -&gt; Iterator[TreeMixin]:         Yields the child elements of the Match clause. solutions(fact_collection: FactCollection | Shim) -&gt; List[Dict[str, Any]]:         Generates solutions based on the given fact collection and constraints.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#pycypher.node_classes.MatchList" title="pycypher.node_classes.MatchList"><code class="xref py py-obj docutils literal notranslate"><span class="pre">MatchList</span></code></a>(match_list)</p></td>
<td><p>Just a container for a list of <code class="docutils literal notranslate"><span class="pre">Match</span></code> objects.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#pycypher.node_classes.Node" title="pycypher.node_classes.Node"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Node</span></code></a>(node_name_label[, mapping_list])</p></td>
<td><p>A node in the graph, which may contain a variable name, label, or mapping.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#pycypher.node_classes.NodeNameLabel" title="pycypher.node_classes.NodeNameLabel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">NodeNameLabel</span></code></a>([name, label])</p></td>
<td><p>A node name, optionally followed by a label, separated by a dot.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#pycypher.node_classes.ObjectAttributeLookup" title="pycypher.node_classes.ObjectAttributeLookup"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ObjectAttributeLookup</span></code></a>(object_name, attribute)</p></td>
<td><p>A node that represents the value of an attribute of a node or relationship of the form <code class="docutils literal notranslate"><span class="pre">node.attribute</span></code>.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#pycypher.node_classes.Or" title="pycypher.node_classes.Or"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Or</span></code></a>(left_side, right_side)</p></td>
<td><p>Represents a logical OR operation between two boolean expressions.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#pycypher.node_classes.Predicate" title="pycypher.node_classes.Predicate"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Predicate</span></code></a>(left_side, right_side)</p></td>
<td><p>A class representing a predicate in a tree structure. Attributes:     left_side_types (Any): The expected type(s) for the left side of the predicate. right_side_types (Any): The expected type(s) for the right side of the predicate. argument_types (Any): The expected type(s) for the arguments of the predicate. left_side (TreeMixin): The left side of the predicate. right_side (TreeMixin): The right side of the predicate. Methods:     children() -&gt; Generator[TreeMixin]:         Yields the children of the predicate (left and right sides). __repr__() -&gt; str:         Returns a string representation of the predicate. _type_check_binary(left_value, right_value):         Checks the types of the left and right values against the expected types. _type_check_unary(value):         Checks the type of a single value against the expected argument type. type_check(<a href="#id1"><span class="problematic" id="id2">*</span></a>args):         Checks the types of the provided arguments. Supports unary and binary predicates.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#pycypher.node_classes.Projection" title="pycypher.node_classes.Projection"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Projection</span></code></a>([lookups])</p></td>
<td><p>A class representing a projection in a tree structure.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#pycypher.node_classes.Query" title="pycypher.node_classes.Query"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Query</span></code></a>(match_clause, return_clause)</p></td>
<td><p>Represents a Cypher query consisting of a MATCH clause and a RETURN clause.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#pycypher.node_classes.Relationship" title="pycypher.node_classes.Relationship"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Relationship</span></code></a>(name_label)</p></td>
<td><p>Relationships may contain a variable name, label, or mapping.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#pycypher.node_classes.RelationshipChain" title="pycypher.node_classes.RelationshipChain"><code class="xref py py-obj docutils literal notranslate"><span class="pre">RelationshipChain</span></code></a>(steps)</p></td>
<td><p>Several <code class="docutils literal notranslate"><span class="pre">Relationship</span></code> nodes chained together, sharing <code class="docutils literal notranslate"><span class="pre">Node</span></code> objects between them.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#pycypher.node_classes.RelationshipChainList" title="pycypher.node_classes.RelationshipChainList"><code class="xref py py-obj docutils literal notranslate"><span class="pre">RelationshipChainList</span></code></a>(relationships)</p></td>
<td><p>A class to represent a list of relationship chains.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#pycypher.node_classes.RelationshipLeftRight" title="pycypher.node_classes.RelationshipLeftRight"><code class="xref py py-obj docutils literal notranslate"><span class="pre">RelationshipLeftRight</span></code></a>(relationship)</p></td>
<td><p>A <code class="docutils literal notranslate"><span class="pre">Relationship</span></code> with the arrow pointing from left to right.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#pycypher.node_classes.RelationshipRightLeft" title="pycypher.node_classes.RelationshipRightLeft"><code class="xref py py-obj docutils literal notranslate"><span class="pre">RelationshipRightLeft</span></code></a>(relationship)</p></td>
<td><p>A <code class="docutils literal notranslate"><span class="pre">Relationship</span></code> with the arrow pointing from right to left.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#pycypher.node_classes.Return" title="pycypher.node_classes.Return"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Return</span></code></a>(node)</p></td>
<td><p>The Return class represents a RETURN clause in a Cypher query.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#pycypher.node_classes.Where" title="pycypher.node_classes.Where"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Where</span></code></a>(predicate)</p></td>
<td><p></p></td>
</tr>
</tbody>
</table>
<dl class="py class">
<dt class="sig sig-object py" id="pycypher.node_classes.Addition">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pycypher.node_classes.</span></span><span class="sig-name descname"><span class="pre">Addition</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">left</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="index.html#pycypher.tree_mixin.TreeMixin" title="pycypher.tree_mixin.TreeMixin"><span class="pre">TreeMixin</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">right</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="index.html#pycypher.tree_mixin.TreeMixin" title="pycypher.tree_mixin.TreeMixin"><span class="pre">TreeMixin</span></a></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pycypher.node_classes.Addition" title="Link to this definition"></a></dt>
<dd><p>Represents an addition operation between two evaluable tree nodes.</p>
<dl class="simple">
<dt>Attributes:</dt><dd><p>left_side_types (type): The allowed types for the left operand (int or float).
right_side_types (type): The allowed types for the right operand (int or float).
left_side (TreeMixin): The left operand of the addition.
right_side (TreeMixin): The right operand of the addition.</p>
</dd>
<dt>Methods:</dt><dd><dl class="simple">
<dt>__init__(left: TreeMixin, right: TreeMixin):</dt><dd><p>Initializes the Addition instance with left and right operands.</p>
</dd>
<dt>__repr__():</dt><dd><p>Returns a string representation of the Addition instance.</p>
</dd>
<dt>tree():</dt><dd><p>Constructs and returns a tree representation of the addition operation.</p>
</dd>
<dt>children():</dt><dd><p>Yields the child nodes (left and right operands) of the addition operation.</p>
</dd>
<dt>_evaluate(fact_collection: FactCollection, projection: Optional[Dict[str, str | List[str]]] = None) -&gt; Any:</dt><dd><p>Evaluates the addition operation using the provided fact collection and optional projection.
Returns the result as a Literal.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="py property">
<dt class="sig sig-object py" id="pycypher.node_classes.Addition.children">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">children</span></span><a class="headerlink" href="#pycypher.node_classes.Addition.children" title="Link to this definition"></a></dt>
<dd><p>Each node should have a children property that returns a generator of its children.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pycypher.node_classes.Addition.tree">
<span class="sig-name descname"><span class="pre">tree</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pycypher.node_classes.Addition.tree" title="Link to this definition"></a></dt>
<dd><p>Generates a tree representation of the AST which can be pretty-printed
with the <code class="docutils literal notranslate"><span class="pre">rich</span></code> library.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pycypher.node_classes.Aggregation">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pycypher.node_classes.</span></span><span class="sig-name descname"><span class="pre">Aggregation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">aggregation</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pycypher.node_classes.Aggregation" title="Link to this definition"></a></dt>
<dd><p>Represents an aggregation operation that transforms a list into a singleton value.</p>
<dl class="simple">
<dt>Attributes:</dt><dd><p>aggregation: The aggregation operation to be performed.</p>
</dd>
<dt>Methods:</dt><dd><p>children: Yields the aggregation operation as a child node.
__repr__: Returns a string representation of the Aggregation instance.
tree: Constructs and returns a tree representation of the aggregation.
_evaluate: Evaluates the aggregation operation using the provided fact collection and projection.</p>
</dd>
</dl>
<dl class="py property">
<dt class="sig sig-object py" id="pycypher.node_classes.Aggregation.children">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">children</span></span><a class="headerlink" href="#pycypher.node_classes.Aggregation.children" title="Link to this definition"></a></dt>
<dd><p>Generator function that yields the aggregation attribute.</p>
<dl class="simple">
<dt>Yields:</dt><dd><p>The aggregation attribute of the instance.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pycypher.node_classes.Aggregation.tree">
<span class="sig-name descname"><span class="pre">tree</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pycypher.node_classes.Aggregation.tree" title="Link to this definition"></a></dt>
<dd><p>Generates a tree representation of the current node class.</p>
<dl class="simple">
<dt>Returns:</dt><dd><p>Tree: A tree object representing the current node class and its aggregation.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pycypher.node_classes.Alias">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pycypher.node_classes.</span></span><span class="sig-name descname"><span class="pre">Alias</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">reference</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.13)"><span class="pre">str</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">alias</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.13)"><span class="pre">str</span></a></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pycypher.node_classes.Alias" title="Link to this definition"></a></dt>
<dd><p>Represents an alias for a reference in a tree structure.</p>
<dl>
<dt>Attributes:</dt><dd><p>reference (str): The original reference.
alias (str): The alias for the reference.</p>
</dd>
<dt>Methods:</dt><dd><p>__repr__(): Returns a string representation of the Alias object.
tree() -&gt; Tree: Constructs a tree representation of the Alias object.
_evaluate(fact_collection: FactCollection, projection: Optional[Dict[str, str | List[str]]] = None) -&gt; Any:</p>
<blockquote>
<div><p>Evaluates the reference and assigns its value to the alias.</p>
</div></blockquote>
<p>children: Yields the reference and alias as children nodes.</p>
</dd>
</dl>
<dl class="py property">
<dt class="sig sig-object py" id="pycypher.node_classes.Alias.children">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">children</span></span><a class="headerlink" href="#pycypher.node_classes.Alias.children" title="Link to this definition"></a></dt>
<dd><p>Each node should have a children property that returns a generator of its children.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pycypher.node_classes.Alias.tree">
<span class="sig-name descname"><span class="pre">tree</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Tree</span></span></span><a class="headerlink" href="#pycypher.node_classes.Alias.tree" title="Link to this definition"></a></dt>
<dd><p>Generates a tree representation of the AST which can be pretty-printed
with the <code class="docutils literal notranslate"><span class="pre">rich</span></code> library.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pycypher.node_classes.AliasedName">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pycypher.node_classes.</span></span><span class="sig-name descname"><span class="pre">AliasedName</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.13)"><span class="pre">str</span></a></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pycypher.node_classes.AliasedName" title="Link to this definition"></a></dt>
<dd><p>A class representing an aliased name with tree structure capabilities.</p>
<dl class="simple">
<dt>Attributes:</dt><dd><p>name (str): The name to be aliased.</p>
</dd>
<dt>Methods:</dt><dd><p>__repr__(): Returns a string representation of the AliasedName instance.
tree() -&gt; Tree: Returns a tree representation of the AliasedName instance.
children() -&gt; Generator[str]: A generator that yields the name as a child node.</p>
</dd>
</dl>
<dl class="py property">
<dt class="sig sig-object py" id="pycypher.node_classes.AliasedName.children">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">children</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">Generator</span><span class="p"><span class="pre">[</span></span><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.13)"><span class="pre">str</span></a><span class="p"><span class="pre">]</span></span></em><a class="headerlink" href="#pycypher.node_classes.AliasedName.children" title="Link to this definition"></a></dt>
<dd><p>Each node should have a children property that returns a generator of its children.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pycypher.node_classes.AliasedName.tree">
<span class="sig-name descname"><span class="pre">tree</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Tree</span></span></span><a class="headerlink" href="#pycypher.node_classes.AliasedName.tree" title="Link to this definition"></a></dt>
<dd><p>Generates a tree representation of the AST which can be pretty-printed
with the <code class="docutils literal notranslate"><span class="pre">rich</span></code> library.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pycypher.node_classes.And">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pycypher.node_classes.</span></span><span class="sig-name descname"><span class="pre">And</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">left_side</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="index.html#pycypher.node_classes.Predicate" title="pycypher.node_classes.Predicate"><span class="pre">Predicate</span></a><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><a class="reference internal" href="index.html#pycypher.node_classes.Literal" title="pycypher.node_classes.Literal"><span class="pre">Literal</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">right_side</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="index.html#pycypher.node_classes.Predicate" title="pycypher.node_classes.Predicate"><span class="pre">Predicate</span></a><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><a class="reference internal" href="index.html#pycypher.node_classes.Literal" title="pycypher.node_classes.Literal"><span class="pre">Literal</span></a></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pycypher.node_classes.And" title="Link to this definition"></a></dt>
<dd><p>Represents a logical AND operation between two boolean expressions.</p>
<section id="methods">
<h6>Methods<a class="headerlink" href="#methods" title="Link to this heading"></a></h6>
<dl class="simple">
<dt>tree() -&gt; Tree</dt><dd><p>Constructs and returns a tree representation of the AND operation.</p>
</dd>
<dt>_evaluate(fact_collection: FactCollection, projection: Optional[Dict[str, str | List[str]]] = None) -&gt; Any</dt><dd><p>Evaluates the AND operation using the provided fact collection and optional projection.
Returns a Literal containing the result of the AND operation.</p>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="pycypher.node_classes.And.tree">
<span class="sig-name descname"><span class="pre">tree</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Tree</span></span></span><a class="headerlink" href="#pycypher.node_classes.And.tree" title="Link to this definition"></a></dt>
<dd><p>Generates a tree representation of the AST which can be pretty-printed
with the <code class="docutils literal notranslate"><span class="pre">rich</span></code> library.</p>
</dd></dl>

</section>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pycypher.node_classes.BinaryBoolean">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pycypher.node_classes.</span></span><span class="sig-name descname"><span class="pre">BinaryBoolean</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">left_side</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="index.html#pycypher.node_classes.Predicate" title="pycypher.node_classes.Predicate"><span class="pre">Predicate</span></a><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><a class="reference internal" href="index.html#pycypher.node_classes.Literal" title="pycypher.node_classes.Literal"><span class="pre">Literal</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">right_side</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="index.html#pycypher.node_classes.Predicate" title="pycypher.node_classes.Predicate"><span class="pre">Predicate</span></a><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><a class="reference internal" href="index.html#pycypher.node_classes.Literal" title="pycypher.node_classes.Literal"><span class="pre">Literal</span></a></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pycypher.node_classes.BinaryBoolean" title="Link to this definition"></a></dt>
<dd><p>A class representing a binary boolean operation in a predicate tree.</p>
<dl class="simple">
<dt>Attributes:</dt><dd><p>left_side (Predicate | Literal): The left side of the binary boolean operation.
right_side (Predicate | Literal): The right side of the binary boolean operation.</p>
</dd>
<dt>Methods:</dt><dd><dl class="simple">
<dt>__init__(left_side: Predicate | Literal, right_side: Predicate | Literal):</dt><dd><p>Initializes the BinaryBoolean instance with the given left and right sides.</p>
</dd>
<dt>__repr__() -&gt; str:</dt><dd><p>Returns a string representation of the BinaryBoolean instance.</p>
</dd>
<dt>tree() -&gt; Tree:</dt><dd><p>Constructs and returns a tree representation of the binary boolean operation.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="pycypher.node_classes.BinaryBoolean.left_side_types">
<span class="sig-name descname"><span class="pre">left_side_types</span></span><a class="headerlink" href="#pycypher.node_classes.BinaryBoolean.left_side_types" title="Link to this definition"></a></dt>
<dd><p>alias of <a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.13)"><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></a></p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pycypher.node_classes.BinaryBoolean.right_side_types">
<span class="sig-name descname"><span class="pre">right_side_types</span></span><a class="headerlink" href="#pycypher.node_classes.BinaryBoolean.right_side_types" title="Link to this definition"></a></dt>
<dd><p>alias of <a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.13)"><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></a></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pycypher.node_classes.BinaryBoolean.tree">
<span class="sig-name descname"><span class="pre">tree</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Tree</span></span></span><a class="headerlink" href="#pycypher.node_classes.BinaryBoolean.tree" title="Link to this definition"></a></dt>
<dd><p>Generates a tree representation of the AST which can be pretty-printed
with the <code class="docutils literal notranslate"><span class="pre">rich</span></code> library.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pycypher.node_classes.Collect">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pycypher.node_classes.</span></span><span class="sig-name descname"><span class="pre">Collect</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">object_attribute_lookup</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="index.html#pycypher.node_classes.ObjectAttributeLookup" title="pycypher.node_classes.ObjectAttributeLookup"><span class="pre">ObjectAttributeLookup</span></a></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pycypher.node_classes.Collect" title="Link to this definition"></a></dt>
<dd><p>A class that represents a collection of objects based on an attribute lookup.</p>
<dl>
<dt>Attributes:</dt><dd><p>object_attribute_lookup (ObjectAttributeLookup): The attribute lookup object used to collect instances.</p>
</dd>
<dt>Methods:</dt><dd><dl>
<dt>children:</dt><dd><p>Yields the object attribute lookup as a child node.</p>
</dd>
<dt>__repr__:</dt><dd><p>Returns a string representation of the Collect instance.</p>
</dd>
<dt>tree:</dt><dd><p>Returns a tree representation of the Collect instance.</p>
</dd>
<dt>_evaluate:</dt><dd><p>Evaluates the collection based on the provided fact collection and projection.
Args:</p>
<blockquote>
<div><p>fact_collection (FactCollection): The collection of facts to evaluate against.
projection (Optional[Dict[str, str | List[str]]]): The projection to use for evaluation.</p>
</div></blockquote>
<dl class="simple">
<dt>Returns:</dt><dd><p>Any: The result of the evaluation.</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
<dl class="py property">
<dt class="sig sig-object py" id="pycypher.node_classes.Collect.children">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">children</span></span><a class="headerlink" href="#pycypher.node_classes.Collect.children" title="Link to this definition"></a></dt>
<dd><p>Each node should have a children property that returns a generator of its children.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pycypher.node_classes.Collect.tree">
<span class="sig-name descname"><span class="pre">tree</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pycypher.node_classes.Collect.tree" title="Link to this definition"></a></dt>
<dd><p>Generates a tree representation of the current object.</p>
<p>This method creates a Tree object with the name of the current class.
It then adds the tree representation of the <cite>object_attribute_lookup</cite> attribute
to the Tree object and returns it.</p>
<dl class="simple">
<dt>Returns:</dt><dd><p>Tree: A tree representation of the current object.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pycypher.node_classes.Collection">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pycypher.node_classes.</span></span><span class="sig-name descname"><span class="pre">Collection</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">values</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3/library/typing.html#typing.List" title="(in Python v3.13)"><span class="pre">List</span></a><span class="p"><span class="pre">[</span></span><a class="reference internal" href="index.html#pycypher.node_classes.Evaluable" title="pycypher.node_classes.Evaluable"><span class="pre">Evaluable</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pycypher.node_classes.Collection" title="Link to this definition"></a></dt>
<dd><p>A class representing a collection of evaluable items.</p>
<dl class="simple">
<dt>Attributes:</dt><dd><p>values (List[Evaluable]): A list of evaluable items.</p>
</dd>
<dt>Methods:</dt><dd><dl class="simple">
<dt>children:</dt><dd><p>Yields the children of the collection.</p>
</dd>
<dt>__repr__:</dt><dd><p>Returns a string representation of the collection.</p>
</dd>
<dt>tree:</dt><dd><p>Constructs and returns a tree representation of the collection.</p>
</dd>
<dt>_evaluate:</dt><dd><p>Evaluates the collection based on the provided fact collection and projection.</p>
</dd>
<dt>__eq__:</dt><dd><p>Checks equality between two Collection instances.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="py property">
<dt class="sig sig-object py" id="pycypher.node_classes.Collection.children">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">children</span></span><a class="headerlink" href="#pycypher.node_classes.Collection.children" title="Link to this definition"></a></dt>
<dd><p>Generator that yields the values of the node.
Yields:</p>
<blockquote>
<div><p>The values contained within the node.</p>
</div></blockquote>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pycypher.node_classes.Collection.tree">
<span class="sig-name descname"><span class="pre">tree</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pycypher.node_classes.Collection.tree" title="Link to this definition"></a></dt>
<dd><p>Generates a tree representation of the AST which can be pretty-printed
with the <code class="docutils literal notranslate"><span class="pre">rich</span></code> library.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pycypher.node_classes.Cypher">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pycypher.node_classes.</span></span><span class="sig-name descname"><span class="pre">Cypher</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cypher</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="index.html#pycypher.tree_mixin.TreeMixin" title="pycypher.tree_mixin.TreeMixin"><span class="pre">TreeMixin</span></a></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pycypher.node_classes.Cypher" title="Link to this definition"></a></dt>
<dd><p>The root node of the Abstract Syntax Tree (AST) for Cypher queries.</p>
<dl class="simple">
<dt>Attributes:</dt><dd><p>cypher (TreeMixin): The root node of the AST.</p>
</dd>
<dt>Methods:</dt><dd><dl class="simple">
<dt>trigger_gather_constraints_to_match():</dt><dd><p>Traverses the AST and triggers the <cite>gather_constraints</cite> method on all <cite>Match</cite> nodes.</p>
</dd>
<dt>children() -&gt; Generator[TreeMixin]:</dt><dd><p>Yields the child nodes of the current node.</p>
</dd>
<dt>__repr__() -&gt; str:</dt><dd><p>Returns a string representation of the Cypher node.</p>
</dd>
<dt>tree() -&gt; Tree:</dt><dd><p>Constructs and returns a tree representation of the AST.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="py property">
<dt class="sig sig-object py" id="pycypher.node_classes.Cypher.children">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">children</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">Generator</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="index.html#pycypher.tree_mixin.TreeMixin" title="pycypher.tree_mixin.TreeMixin"><span class="pre">TreeMixin</span></a><span class="p"><span class="pre">]</span></span></em><a class="headerlink" href="#pycypher.node_classes.Cypher.children" title="Link to this definition"></a></dt>
<dd><p>Generator function that yields the children of the current node.</p>
<dl class="simple">
<dt>Yields:</dt><dd><p>TreeMixin: The child node of the current node.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pycypher.node_classes.Cypher.tree">
<span class="sig-name descname"><span class="pre">tree</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Tree</span></span></span><a class="headerlink" href="#pycypher.node_classes.Cypher.tree" title="Link to this definition"></a></dt>
<dd><p>Generates a tree representation of the current node.</p>
<dl class="simple">
<dt>Returns:</dt><dd><p>Tree: A tree object representing the current node and its Cypher tree.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pycypher.node_classes.Cypher.trigger_gather_constraints_to_match">
<span class="sig-name descname"><span class="pre">trigger_gather_constraints_to_match</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pycypher.node_classes.Cypher.trigger_gather_constraints_to_match" title="Link to this definition"></a></dt>
<dd><p>Triggers the gathering of constraints for all nodes of type ‘Match’ in the current context.</p>
<p>This method iterates over all nodes returned by the <cite>walk</cite> method. For each node that is an
instance of the <cite>Match</cite> class, it calls the <cite>gather_constraints</cite> method on that node.</p>
<dl class="simple">
<dt>Returns:</dt><dd><p>None</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pycypher.node_classes.Distinct">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pycypher.node_classes.</span></span><span class="sig-name descname"><span class="pre">Distinct</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">collection</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="index.html#pycypher.node_classes.Collection" title="pycypher.node_classes.Collection"><span class="pre">Collection</span></a></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pycypher.node_classes.Distinct" title="Link to this definition"></a></dt>
<dd><p>A class that represents a distinct operation on a collection, removing duplicate values.</p>
<dl class="simple">
<dt>Attributes:</dt><dd><p>collection (Collection): The collection to be evaluated and filtered for distinct values.</p>
</dd>
<dt>Methods:</dt><dd><dl class="simple">
<dt>children:</dt><dd><p>Yields the collection as a child node.</p>
</dd>
<dt>__repr__:</dt><dd><p>Returns a string representation of the Distinct instance.</p>
</dd>
<dt>tree:</dt><dd><p>Constructs and returns a tree representation of the Distinct instance.</p>
</dd>
<dt>_evaluate:</dt><dd><p>Evaluates the collection, removes duplicate values, and returns a new collection with distinct values.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="py property">
<dt class="sig sig-object py" id="pycypher.node_classes.Distinct.children">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">children</span></span><a class="headerlink" href="#pycypher.node_classes.Distinct.children" title="Link to this definition"></a></dt>
<dd><p>Generator that yields the collection of children nodes.</p>
<dl class="simple">
<dt>Yields:</dt><dd><p>The collection of children nodes.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pycypher.node_classes.Distinct.tree">
<span class="sig-name descname"><span class="pre">tree</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pycypher.node_classes.Distinct.tree" title="Link to this definition"></a></dt>
<dd><p>Generates a tree representation of the current node class.</p>
<dl class="simple">
<dt>Returns:</dt><dd><p>Tree: A tree object representing the current node class and its collection.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pycypher.node_classes.Division">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pycypher.node_classes.</span></span><span class="sig-name descname"><span class="pre">Division</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">left_side</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="index.html#pycypher.tree_mixin.TreeMixin" title="pycypher.tree_mixin.TreeMixin"><span class="pre">TreeMixin</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">right_side</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="index.html#pycypher.tree_mixin.TreeMixin" title="pycypher.tree_mixin.TreeMixin"><span class="pre">TreeMixin</span></a></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pycypher.node_classes.Division" title="Link to this definition"></a></dt>
<dd><p>Represents a division operation in an expression tree.</p>
<dl class="simple">
<dt>Attributes:</dt><dd><p>left_side_types (Union[int, float]): Allowed types for the left operand.
right_side_types (Union[PositiveFloat, PositiveInt]): Allowed types for the right operand.</p>
</dd>
<dt>Methods:</dt><dd><dl class="simple">
<dt>tree() -&gt; Tree:</dt><dd><p>Constructs and returns a tree representation of the division operation.</p>
</dd>
<dt>_evaluate(fact_collection: FactCollection, projection: Optional[Dict[str, Union[str, List[str]]]] = None) -&gt; Any:</dt><dd><p>Evaluates the division operation using the provided fact collection and optional projection.
Returns the result as a Literal.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="pycypher.node_classes.Division.right_side_types">
<span class="sig-name descname"><span class="pre">right_side_types</span></span><a class="headerlink" href="#pycypher.node_classes.Division.right_side_types" title="Link to this definition"></a></dt>
<dd><p>alias of <code class="xref py py-class docutils literal notranslate"><span class="pre">Annotated</span></code>[<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.13)"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></a>, <code class="xref py py-class docutils literal notranslate"><span class="pre">Gt</span></code>(gt=0)] | <code class="xref py py-class docutils literal notranslate"><span class="pre">Annotated</span></code>[<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.13)"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a>, <code class="xref py py-class docutils literal notranslate"><span class="pre">Gt</span></code>(gt=0)] | <code class="xref py py-class docutils literal notranslate"><span class="pre">Annotated</span></code>[<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.13)"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></a>, <code class="xref py py-class docutils literal notranslate"><span class="pre">Lt</span></code>(lt=0)] | <code class="xref py py-class docutils literal notranslate"><span class="pre">Annotated</span></code>[<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.13)"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a>, <code class="xref py py-class docutils literal notranslate"><span class="pre">Lt</span></code>(lt=0)]</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pycypher.node_classes.Division.tree">
<span class="sig-name descname"><span class="pre">tree</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Tree</span></span></span><a class="headerlink" href="#pycypher.node_classes.Division.tree" title="Link to this definition"></a></dt>
<dd><p>Generates a tree representation of the AST which can be pretty-printed
with the <code class="docutils literal notranslate"><span class="pre">rich</span></code> library.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pycypher.node_classes.Equals">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pycypher.node_classes.</span></span><span class="sig-name descname"><span class="pre">Equals</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">left_side</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="index.html#pycypher.node_classes.Predicate" title="pycypher.node_classes.Predicate"><span class="pre">Predicate</span></a><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><a class="reference internal" href="index.html#pycypher.node_classes.Literal" title="pycypher.node_classes.Literal"><span class="pre">Literal</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">right_side</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="index.html#pycypher.node_classes.Predicate" title="pycypher.node_classes.Predicate"><span class="pre">Predicate</span></a><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><a class="reference internal" href="index.html#pycypher.node_classes.Literal" title="pycypher.node_classes.Literal"><span class="pre">Literal</span></a></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pycypher.node_classes.Equals" title="Link to this definition"></a></dt>
<dd><p>Binary infix operator for equality.</p>
<dl class="py method">
<dt class="sig sig-object py" id="pycypher.node_classes.Equals.tree">
<span class="sig-name descname"><span class="pre">tree</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Tree</span></span></span><a class="headerlink" href="#pycypher.node_classes.Equals.tree" title="Link to this definition"></a></dt>
<dd><p>Generates a tree representation of the AST which can be pretty-printed
with the <code class="docutils literal notranslate"><span class="pre">rich</span></code> library.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pycypher.node_classes.Evaluable">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pycypher.node_classes.</span></span><span class="sig-name descname"><span class="pre">Evaluable</span></span><a class="headerlink" href="#pycypher.node_classes.Evaluable" title="Link to this definition"></a></dt>
<dd><p>Abstract base class representing an evaluable entity.</p>
<section id="id3">
<h6>Methods<a class="headerlink" href="#id3" title="Link to this heading"></a></h6>
<dl class="simple">
<dt>_evaluate(fact_collection: FactCollection, projection: Optional[Dict[str, str | List[str]]] = None) -&gt; Any</dt><dd><p>Abstract method to be implemented by subclasses to perform evaluation based on the provided fact collection and optional projection.</p>
</dd>
<dt>evaluate(<a href="#id4"><span class="problematic" id="id5">*</span></a>args, <a href="#id6"><span class="problematic" id="id7">**</span></a>kwargs)</dt><dd><p>Calls the <cite>_evaluate</cite> method and returns the value of the <cite>Literal</cite> object.</p>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="pycypher.node_classes.Evaluable.evaluate">
<span class="sig-name descname"><span class="pre">evaluate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pycypher.node_classes.Evaluable.evaluate" title="Link to this definition"></a></dt>
<dd><p>Calls the <cite>_evaluate</cite> method and returns the value of the <cite>Literal</cite> object.</p>
</dd></dl>

</section>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pycypher.node_classes.GreaterThan">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pycypher.node_classes.</span></span><span class="sig-name descname"><span class="pre">GreaterThan</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">left_side</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="index.html#pycypher.tree_mixin.TreeMixin" title="pycypher.tree_mixin.TreeMixin"><span class="pre">TreeMixin</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">right_side</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="index.html#pycypher.tree_mixin.TreeMixin" title="pycypher.tree_mixin.TreeMixin"><span class="pre">TreeMixin</span></a></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pycypher.node_classes.GreaterThan" title="Link to this definition"></a></dt>
<dd><p>Binary infix operator for greater than.</p>
<dl class="py method">
<dt class="sig sig-object py" id="pycypher.node_classes.GreaterThan.tree">
<span class="sig-name descname"><span class="pre">tree</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Tree</span></span></span><a class="headerlink" href="#pycypher.node_classes.GreaterThan.tree" title="Link to this definition"></a></dt>
<dd><p>Generates a tree representation of the AST which can be pretty-printed
with the <code class="docutils literal notranslate"><span class="pre">rich</span></code> library.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pycypher.node_classes.LessThan">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pycypher.node_classes.</span></span><span class="sig-name descname"><span class="pre">LessThan</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">left_side</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="index.html#pycypher.tree_mixin.TreeMixin" title="pycypher.tree_mixin.TreeMixin"><span class="pre">TreeMixin</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">right_side</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="index.html#pycypher.tree_mixin.TreeMixin" title="pycypher.tree_mixin.TreeMixin"><span class="pre">TreeMixin</span></a></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pycypher.node_classes.LessThan" title="Link to this definition"></a></dt>
<dd><p>Binary infix operator for less than.</p>
<dl class="py method">
<dt class="sig sig-object py" id="pycypher.node_classes.LessThan.tree">
<span class="sig-name descname"><span class="pre">tree</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Tree</span></span></span><a class="headerlink" href="#pycypher.node_classes.LessThan.tree" title="Link to this definition"></a></dt>
<dd><p>Generates a tree representation of the AST which can be pretty-printed
with the <code class="docutils literal notranslate"><span class="pre">rich</span></code> library.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pycypher.node_classes.Literal">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pycypher.node_classes.</span></span><span class="sig-name descname"><span class="pre">Literal</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">value</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3/library/typing.html#typing.Any" title="(in Python v3.13)"><span class="pre">Any</span></a></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pycypher.node_classes.Literal" title="Link to this definition"></a></dt>
<dd><p>A class representing a literal value in a tree structure.</p>
<dl>
<dt>Attributes:</dt><dd><p>value (Any): The literal value.</p>
</dd>
<dt>Methods:</dt><dd><p>__repr__(): Returns a string representation of the Literal instance.
tree(): Returns a tree representation of the Literal instance.
_evaluate(fact_collection: FactCollection, projection: Optional[Dict[str, str | List[str]]] = None) -&gt; Any:</p>
<blockquote>
<div><p>Evaluates and returns a new Literal instance with the same value.</p>
</div></blockquote>
<p>__eq__(other): Checks equality between two Literal instances based on their values.</p>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="pycypher.node_classes.Literal.tree">
<span class="sig-name descname"><span class="pre">tree</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pycypher.node_classes.Literal.tree" title="Link to this definition"></a></dt>
<dd><p>Generates a tree representation of the AST which can be pretty-printed
with the <code class="docutils literal notranslate"><span class="pre">rich</span></code> library.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pycypher.node_classes.Mapping">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pycypher.node_classes.</span></span><span class="sig-name descname"><span class="pre">Mapping</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">key</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.13)"><span class="pre">str</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">value</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3/library/typing.html#typing.Any" title="(in Python v3.13)"><span class="pre">Any</span></a></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pycypher.node_classes.Mapping" title="Link to this definition"></a></dt>
<dd><p>Mappings are dictionaries of key-value pairs.</p>
<dl class="py property">
<dt class="sig sig-object py" id="pycypher.node_classes.Mapping.children">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">children</span></span><a class="headerlink" href="#pycypher.node_classes.Mapping.children" title="Link to this definition"></a></dt>
<dd><p>Each node should have a children property that returns a generator of its children.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pycypher.node_classes.Mapping.constraints">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">constraints</span></span><a class="headerlink" href="#pycypher.node_classes.Mapping.constraints" title="Link to this definition"></a></dt>
<dd><p>Generates the <code class="docutils literal notranslate"><span class="pre">Constraint</span></code> objects that correspond to this node.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pycypher.node_classes.Mapping.tree">
<span class="sig-name descname"><span class="pre">tree</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pycypher.node_classes.Mapping.tree" title="Link to this definition"></a></dt>
<dd><p>Generates a tree representation of the AST which can be pretty-printed
with the <code class="docutils literal notranslate"><span class="pre">rich</span></code> library.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pycypher.node_classes.MappingSet">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pycypher.node_classes.</span></span><span class="sig-name descname"><span class="pre">MappingSet</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mappings</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3/library/typing.html#typing.List" title="(in Python v3.13)"><span class="pre">List</span></a><span class="p"><span class="pre">[</span></span><a class="reference internal" href="index.html#pycypher.node_classes.Mapping" title="pycypher.node_classes.Mapping"><span class="pre">Mapping</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pycypher.node_classes.MappingSet" title="Link to this definition"></a></dt>
<dd><p>A list of mappings.</p>
<dl class="py property">
<dt class="sig sig-object py" id="pycypher.node_classes.MappingSet.children">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">children</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">Generator</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="index.html#pycypher.node_classes.Mapping" title="pycypher.node_classes.Mapping"><span class="pre">Mapping</span></a><span class="p"><span class="pre">]</span></span></em><a class="headerlink" href="#pycypher.node_classes.MappingSet.children" title="Link to this definition"></a></dt>
<dd><p>Each node should have a children property that returns a generator of its children.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pycypher.node_classes.MappingSet.tree">
<span class="sig-name descname"><span class="pre">tree</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Tree</span></span></span><a class="headerlink" href="#pycypher.node_classes.MappingSet.tree" title="Link to this definition"></a></dt>
<dd><p>Generates a tree representation of the AST which can be pretty-printed
with the <code class="docutils literal notranslate"><span class="pre">rich</span></code> library.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pycypher.node_classes.Match">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pycypher.node_classes.</span></span><span class="sig-name descname"><span class="pre">Match</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">pattern</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="index.html#pycypher.tree_mixin.TreeMixin" title="pycypher.tree_mixin.TreeMixin"><span class="pre">TreeMixin</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">where</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="index.html#pycypher.tree_mixin.TreeMixin" title="pycypher.tree_mixin.TreeMixin"><span class="pre">TreeMixin</span></a><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><a class="reference external" href="https://docs.python.org/3/library/constants.html#None" title="(in Python v3.13)"><span class="pre">None</span></a></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">with_clause</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="index.html#pycypher.tree_mixin.TreeMixin" title="pycypher.tree_mixin.TreeMixin"><span class="pre">TreeMixin</span></a><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><a class="reference external" href="https://docs.python.org/3/library/constants.html#None" title="(in Python v3.13)"><span class="pre">None</span></a></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">constraints</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3/library/typing.html#typing.List" title="(in Python v3.13)"><span class="pre">List</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Constraint</span><span class="p"><span class="pre">]</span></span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><a class="reference external" href="https://docs.python.org/3/library/constants.html#None" title="(in Python v3.13)"><span class="pre">None</span></a></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pycypher.node_classes.Match" title="Link to this definition"></a></dt>
<dd><p>Represents a MATCH clause in a Cypher query.
Attributes:</p>
<blockquote>
<div><p>pattern (TreeMixin): The pattern to match in the query.
where (Optional[TreeMixin]): An optional WHERE clause to filter the results.
with_clause (Optional[TreeMixin]): An optional WITH clause to chain queries.
constraints (Optional[List[Constraint]]): A list of constraints to apply to the match.</p>
</div></blockquote>
<dl class="simple">
<dt>Methods:</dt><dd><dl class="simple">
<dt>__repr__() -&gt; str:</dt><dd><p>Returns a string representation of the Match object.</p>
</dd>
<dt>gather_constraints() -&gt; None:</dt><dd><p>Gathers all the Constraint objects from inside the Match clause.</p>
</dd>
<dt>tree() -&gt; Tree:</dt><dd><p>Constructs and returns a tree representation of the Match clause.</p>
</dd>
<dt>children() -&gt; Iterator[TreeMixin]:</dt><dd><p>Yields the child elements of the Match clause.</p>
</dd>
<dt>solutions(fact_collection: FactCollection | Shim) -&gt; List[Dict[str, Any]]:</dt><dd><p>Generates solutions based on the given fact collection and constraints.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="py property">
<dt class="sig sig-object py" id="pycypher.node_classes.Match.children">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">children</span></span><a class="headerlink" href="#pycypher.node_classes.Match.children" title="Link to this definition"></a></dt>
<dd><p>Each node should have a children property that returns a generator of its children.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pycypher.node_classes.Match.gather_constraints">
<span class="sig-name descname"><span class="pre">gather_constraints</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference external" href="https://docs.python.org/3/library/constants.html#None" title="(in Python v3.13)"><span class="pre">None</span></a></span></span><a class="headerlink" href="#pycypher.node_classes.Match.gather_constraints" title="Link to this definition"></a></dt>
<dd><p>Gather all the <code class="docutils literal notranslate"><span class="pre">Constraint</span></code> objects from inside the <code class="docutils literal notranslate"><span class="pre">Match</span></code> clause.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pycypher.node_classes.Match.solutions">
<span class="sig-name descname"><span class="pre">solutions</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fact_collection</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="index.html#pycypher.fact.FactCollection" title="pycypher.fact.FactCollection"><span class="pre">FactCollection</span></a><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><a class="reference internal" href="index.html#pycypher.shims.Shim" title="pycypher.shims.Shim"><span class="pre">Shim</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference external" href="https://docs.python.org/3/library/typing.html#typing.List" title="(in Python v3.13)"><span class="pre">List</span></a><span class="p"><span class="pre">[</span></span><a class="reference external" href="https://docs.python.org/3/library/typing.html#typing.Dict" title="(in Python v3.13)"><span class="pre">Dict</span></a><span class="p"><span class="pre">[</span></span><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.13)"><span class="pre">str</span></a><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference external" href="https://docs.python.org/3/library/typing.html#typing.Any" title="(in Python v3.13)"><span class="pre">Any</span></a><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pycypher.node_classes.Match.solutions" title="Link to this definition"></a></dt>
<dd><p>Generate solutions based on the given fact collection and constraints.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>fact_collection (FactCollection | Shim): A collection of facts or a shim that can be converted to a fact collection.</p>
</dd>
<dt>Returns:</dt><dd><p>List[Dict[str, Any]]: A list of dictionaries representing the solutions that satisfy the constraints.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pycypher.node_classes.Match.tree">
<span class="sig-name descname"><span class="pre">tree</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Tree</span></span></span><a class="headerlink" href="#pycypher.node_classes.Match.tree" title="Link to this definition"></a></dt>
<dd><p>Generates a tree representation of the AST which can be pretty-printed
with the <code class="docutils literal notranslate"><span class="pre">rich</span></code> library.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pycypher.node_classes.MatchList">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pycypher.node_classes.</span></span><span class="sig-name descname"><span class="pre">MatchList</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">match_list</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3/library/typing.html#typing.List" title="(in Python v3.13)"><span class="pre">List</span></a><span class="p"><span class="pre">[</span></span><a class="reference internal" href="index.html#pycypher.node_classes.Match" title="pycypher.node_classes.Match"><span class="pre">Match</span></a><span class="p"><span class="pre">]</span></span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><a class="reference external" href="https://docs.python.org/3/library/constants.html#None" title="(in Python v3.13)"><span class="pre">None</span></a></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pycypher.node_classes.MatchList" title="Link to this definition"></a></dt>
<dd><p>Just a container for a list of <code class="docutils literal notranslate"><span class="pre">Match</span></code> objects.</p>
<dl class="py method">
<dt class="sig sig-object py" id="pycypher.node_classes.MatchList.tree">
<span class="sig-name descname"><span class="pre">tree</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Tree</span></span></span><a class="headerlink" href="#pycypher.node_classes.MatchList.tree" title="Link to this definition"></a></dt>
<dd><p>Generates a tree representation of the AST which can be pretty-printed
with the <code class="docutils literal notranslate"><span class="pre">rich</span></code> library.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pycypher.node_classes.Multiplication">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pycypher.node_classes.</span></span><span class="sig-name descname"><span class="pre">Multiplication</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">left_side</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="index.html#pycypher.tree_mixin.TreeMixin" title="pycypher.tree_mixin.TreeMixin"><span class="pre">TreeMixin</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">right_side</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="index.html#pycypher.tree_mixin.TreeMixin" title="pycypher.tree_mixin.TreeMixin"><span class="pre">TreeMixin</span></a></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pycypher.node_classes.Multiplication" title="Link to this definition"></a></dt>
<dd><p>A class representing a multiplication operation in a predicate logic expression.</p>
<dl class="simple">
<dt>Attributes:</dt><dd><p>left_side_types (type): The allowed types for the left operand (float or int).
right_side_types (type): The allowed types for the right operand (float or int).</p>
</dd>
<dt>Methods:</dt><dd><dl class="simple">
<dt>tree() -&gt; Tree:</dt><dd><p>Constructs and returns a tree representation of the multiplication operation.</p>
</dd>
<dt>_evaluate(fact_collection: FactCollection, projection: Optional[Dict[str, str | List[str]]] = None) -&gt; Any:</dt><dd><p>Evaluates the multiplication operation using the provided fact collection and optional projection.
Returns a Literal object containing the result of the multiplication.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="pycypher.node_classes.Multiplication.tree">
<span class="sig-name descname"><span class="pre">tree</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Tree</span></span></span><a class="headerlink" href="#pycypher.node_classes.Multiplication.tree" title="Link to this definition"></a></dt>
<dd><p>Generates a tree representation of the AST which can be pretty-printed
with the <code class="docutils literal notranslate"><span class="pre">rich</span></code> library.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pycypher.node_classes.Node">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pycypher.node_classes.</span></span><span class="sig-name descname"><span class="pre">Node</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">node_name_label</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="index.html#pycypher.node_classes.NodeNameLabel" title="pycypher.node_classes.NodeNameLabel"><span class="pre">NodeNameLabel</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">mapping_list</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3/library/typing.html#typing.List" title="(in Python v3.13)"><span class="pre">List</span></a><span class="p"><span class="pre">[</span></span><a class="reference internal" href="index.html#pycypher.node_classes.Mapping" title="pycypher.node_classes.Mapping"><span class="pre">Mapping</span></a><span class="p"><span class="pre">]</span></span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><a class="reference external" href="https://docs.python.org/3/library/constants.html#None" title="(in Python v3.13)"><span class="pre">None</span></a></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pycypher.node_classes.Node" title="Link to this definition"></a></dt>
<dd><p>A node in the graph, which may contain a variable name, label, or mapping.</p>
<dl class="py property">
<dt class="sig sig-object py" id="pycypher.node_classes.Node.children">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">children</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">Generator</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="index.html#pycypher.node_classes.NodeNameLabel" title="pycypher.node_classes.NodeNameLabel"><span class="pre">NodeNameLabel</span></a><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><a class="reference internal" href="index.html#pycypher.node_classes.Mapping" title="pycypher.node_classes.Mapping"><span class="pre">Mapping</span></a><span class="p"><span class="pre">]</span></span></em><a class="headerlink" href="#pycypher.node_classes.Node.children" title="Link to this definition"></a></dt>
<dd><p>Each node should have a children property that returns a generator of its children.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pycypher.node_classes.Node.constraints">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">constraints</span></span><a class="headerlink" href="#pycypher.node_classes.Node.constraints" title="Link to this definition"></a></dt>
<dd><p>Hi</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pycypher.node_classes.Node.tree">
<span class="sig-name descname"><span class="pre">tree</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Tree</span></span></span><a class="headerlink" href="#pycypher.node_classes.Node.tree" title="Link to this definition"></a></dt>
<dd><p>Generates a tree representation of the AST which can be pretty-printed
with the <code class="docutils literal notranslate"><span class="pre">rich</span></code> library.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pycypher.node_classes.NodeNameLabel">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pycypher.node_classes.</span></span><span class="sig-name descname"><span class="pre">NodeNameLabel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.13)"><span class="pre">str</span></a><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><a class="reference external" href="https://docs.python.org/3/library/constants.html#None" title="(in Python v3.13)"><span class="pre">None</span></a></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">label</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.13)"><span class="pre">str</span></a><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><a class="reference external" href="https://docs.python.org/3/library/constants.html#None" title="(in Python v3.13)"><span class="pre">None</span></a></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pycypher.node_classes.NodeNameLabel" title="Link to this definition"></a></dt>
<dd><p>A node name, optionally followed by a label, separated by a dot.</p>
<dl class="py property">
<dt class="sig sig-object py" id="pycypher.node_classes.NodeNameLabel.children">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">children</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">Generator</span><span class="p"><span class="pre">[</span></span><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.13)"><span class="pre">str</span></a><span class="p"><span class="pre">]</span></span></em><a class="headerlink" href="#pycypher.node_classes.NodeNameLabel.children" title="Link to this definition"></a></dt>
<dd><p>Each node should have a children property that returns a generator of its children.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pycypher.node_classes.NodeNameLabel.tree">
<span class="sig-name descname"><span class="pre">tree</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pycypher.node_classes.NodeNameLabel.tree" title="Link to this definition"></a></dt>
<dd><p>Generates a tree representation of the AST which can be pretty-printed
with the <code class="docutils literal notranslate"><span class="pre">rich</span></code> library.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pycypher.node_classes.Not">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pycypher.node_classes.</span></span><span class="sig-name descname"><span class="pre">Not</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">argument</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="index.html#pycypher.node_classes.Predicate" title="pycypher.node_classes.Predicate"><span class="pre">Predicate</span></a><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><a class="reference internal" href="index.html#pycypher.node_classes.Literal" title="pycypher.node_classes.Literal"><span class="pre">Literal</span></a></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pycypher.node_classes.Not" title="Link to this definition"></a></dt>
<dd><p>Represents a logical NOT operation in a predicate expression.</p>
<dl>
<dt>Inherits from:</dt><dd><p>Evaluable: Base class for evaluable expressions.
Predicate: Base class for predicate expressions.</p>
</dd>
<dt>Attributes:</dt><dd><p>argument_types (type): The expected type of the argument, which is a boolean.</p>
</dd>
<dt>Args:</dt><dd><p>argument (Predicate | Literal): The predicate or literal to be negated.</p>
</dd>
<dt>Methods:</dt><dd><p>__repr__(): Returns a string representation of the Not instance.
tree() -&gt; Tree: Constructs and returns a tree representation of the Not instance.
_evaluate(fact_collection: FactCollection, projection: Optional[Dict[str, str | List[str]]] = None) -&gt; Any:</p>
<blockquote>
<div><p>Evaluates the NOT operation on the provided fact collection and optional projection.</p>
</div></blockquote>
</dd>
</dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="pycypher.node_classes.Not.argument_types">
<span class="sig-name descname"><span class="pre">argument_types</span></span><a class="headerlink" href="#pycypher.node_classes.Not.argument_types" title="Link to this definition"></a></dt>
<dd><p>alias of <a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.13)"><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></a></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pycypher.node_classes.Not.tree">
<span class="sig-name descname"><span class="pre">tree</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Tree</span></span></span><a class="headerlink" href="#pycypher.node_classes.Not.tree" title="Link to this definition"></a></dt>
<dd><p>Generates a tree representation of the AST which can be pretty-printed
with the <code class="docutils literal notranslate"><span class="pre">rich</span></code> library.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pycypher.node_classes.ObjectAsSeries">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pycypher.node_classes.</span></span><span class="sig-name descname"><span class="pre">ObjectAsSeries</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">object_attribute_lookup_list</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3/library/typing.html#typing.List" title="(in Python v3.13)"><span class="pre">List</span></a><span class="p"><span class="pre">[</span></span><a class="reference internal" href="index.html#pycypher.node_classes.Alias" title="pycypher.node_classes.Alias"><span class="pre">Alias</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pycypher.node_classes.ObjectAsSeries" title="Link to this definition"></a></dt>
<dd><p>A class that represents an object as a series of attributes.</p>
<dl class="simple">
<dt>Attributes:</dt><dd><p>object_attribute_lookup_list (List[Alias]): A list of Alias objects representing the attributes of the object.</p>
</dd>
<dt>Methods:</dt><dd><dl class="simple">
<dt>__repr__():</dt><dd><p>Returns a string representation of the ObjectAsSeries instance.</p>
</dd>
<dt>tree() -&gt; Tree:</dt><dd><p>Constructs and returns a Tree representation of the object and its attributes.</p>
</dd>
<dt>children() -&gt; Generator[Projection | Alias]:</dt><dd><p>A property that yields the children of the object, which are the attributes in the object_attribute_lookup_list.</p>
</dd>
<dt>_evaluate(fact_collection: FactCollection, projection: Optional[Dict[str, str | List[str]]] = None) -&gt; Any:</dt><dd><p>Evaluates the object attributes against a given fact collection and optional projection, returning the result as a dictionary.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="py property">
<dt class="sig sig-object py" id="pycypher.node_classes.ObjectAsSeries.children">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">children</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">Generator</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="index.html#pycypher.node_classes.Projection" title="pycypher.node_classes.Projection"><span class="pre">Projection</span></a><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><a class="reference internal" href="index.html#pycypher.node_classes.Alias" title="pycypher.node_classes.Alias"><span class="pre">Alias</span></a><span class="p"><span class="pre">]</span></span></em><a class="headerlink" href="#pycypher.node_classes.ObjectAsSeries.children" title="Link to this definition"></a></dt>
<dd><p>Each node should have a children property that returns a generator of its children.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pycypher.node_classes.ObjectAsSeries.tree">
<span class="sig-name descname"><span class="pre">tree</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Tree</span></span></span><a class="headerlink" href="#pycypher.node_classes.ObjectAsSeries.tree" title="Link to this definition"></a></dt>
<dd><p>Generates a tree representation of the AST which can be pretty-printed
with the <code class="docutils literal notranslate"><span class="pre">rich</span></code> library.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pycypher.node_classes.ObjectAttributeLookup">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pycypher.node_classes.</span></span><span class="sig-name descname"><span class="pre">ObjectAttributeLookup</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">object_name</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.13)"><span class="pre">str</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">attribute</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.13)"><span class="pre">str</span></a></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pycypher.node_classes.ObjectAttributeLookup" title="Link to this definition"></a></dt>
<dd><p>A node that represents the value of an attribute of a node or relationship
of the form <code class="docutils literal notranslate"><span class="pre">node.attribute</span></code>.</p>
<dl class="py property">
<dt class="sig sig-object py" id="pycypher.node_classes.ObjectAttributeLookup.children">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">children</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">Generator</span><span class="p"><span class="pre">[</span></span><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.13)"><span class="pre">str</span></a><span class="p"><span class="pre">]</span></span></em><a class="headerlink" href="#pycypher.node_classes.ObjectAttributeLookup.children" title="Link to this definition"></a></dt>
<dd><p>Each node should have a children property that returns a generator of its children.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pycypher.node_classes.ObjectAttributeLookup.tree">
<span class="sig-name descname"><span class="pre">tree</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Tree</span></span></span><a class="headerlink" href="#pycypher.node_classes.ObjectAttributeLookup.tree" title="Link to this definition"></a></dt>
<dd><p>Generates a tree representation of the AST which can be pretty-printed
with the <code class="docutils literal notranslate"><span class="pre">rich</span></code> library.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pycypher.node_classes.ObjectAttributeLookup.value">
<span class="sig-name descname"><span class="pre">value</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fact_collection</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="index.html#pycypher.fact.FactCollection" title="pycypher.fact.FactCollection"><span class="pre">FactCollection</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference external" href="https://docs.python.org/3/library/typing.html#typing.Any" title="(in Python v3.13)"><span class="pre">Any</span></a></span></span><a class="headerlink" href="#pycypher.node_classes.ObjectAttributeLookup.value" title="Link to this definition"></a></dt>
<dd><p>Need to find reference of variable from previous Match clause.
Then look up the attribute for that object from the FactCollection.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pycypher.node_classes.Or">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pycypher.node_classes.</span></span><span class="sig-name descname"><span class="pre">Or</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">left_side</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="index.html#pycypher.node_classes.Predicate" title="pycypher.node_classes.Predicate"><span class="pre">Predicate</span></a><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><a class="reference internal" href="index.html#pycypher.node_classes.Literal" title="pycypher.node_classes.Literal"><span class="pre">Literal</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">right_side</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="index.html#pycypher.node_classes.Predicate" title="pycypher.node_classes.Predicate"><span class="pre">Predicate</span></a><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><a class="reference internal" href="index.html#pycypher.node_classes.Literal" title="pycypher.node_classes.Literal"><span class="pre">Literal</span></a></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pycypher.node_classes.Or" title="Link to this definition"></a></dt>
<dd><p>Represents a logical OR operation between two boolean expressions.</p>
<section id="id8">
<h6>Methods<a class="headerlink" href="#id8" title="Link to this heading"></a></h6>
<dl class="simple">
<dt>tree() -&gt; Tree</dt><dd><p>Constructs and returns a tree representation of the OR operation.</p>
</dd>
<dt>_evaluate(fact_collection: FactCollection, projection: Optional[Dict[str, str | List[str]]] = None) -&gt; Any</dt><dd><p>Evaluates the OR operation using the provided fact collection and optional projection.
Returns a Literal containing the result of the OR operation.</p>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="pycypher.node_classes.Or.tree">
<span class="sig-name descname"><span class="pre">tree</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Tree</span></span></span><a class="headerlink" href="#pycypher.node_classes.Or.tree" title="Link to this definition"></a></dt>
<dd><p>Generates a tree representation of the AST which can be pretty-printed
with the <code class="docutils literal notranslate"><span class="pre">rich</span></code> library.</p>
</dd></dl>

</section>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pycypher.node_classes.Predicate">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pycypher.node_classes.</span></span><span class="sig-name descname"><span class="pre">Predicate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">left_side</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="index.html#pycypher.tree_mixin.TreeMixin" title="pycypher.tree_mixin.TreeMixin"><span class="pre">TreeMixin</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">right_side</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="index.html#pycypher.tree_mixin.TreeMixin" title="pycypher.tree_mixin.TreeMixin"><span class="pre">TreeMixin</span></a></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pycypher.node_classes.Predicate" title="Link to this definition"></a></dt>
<dd><p>A class representing a predicate in a tree structure.
Attributes:</p>
<blockquote>
<div><p>left_side_types (Any): The expected type(s) for the left side of the predicate.
right_side_types (Any): The expected type(s) for the right side of the predicate.
argument_types (Any): The expected type(s) for the arguments of the predicate.
left_side (TreeMixin): The left side of the predicate.
right_side (TreeMixin): The right side of the predicate.</p>
</div></blockquote>
<dl class="simple">
<dt>Methods:</dt><dd><dl class="simple">
<dt>children() -&gt; Generator[TreeMixin]:</dt><dd><p>Yields the children of the predicate (left and right sides).</p>
</dd>
<dt>__repr__() -&gt; str:</dt><dd><p>Returns a string representation of the predicate.</p>
</dd>
<dt>_type_check_binary(left_value, right_value):</dt><dd><p>Checks the types of the left and right values against the expected types.</p>
</dd>
<dt>_type_check_unary(value):</dt><dd><p>Checks the type of a single value against the expected argument type.</p>
</dd>
<dt>type_check(<a href="#id9"><span class="problematic" id="id10">*</span></a>args):</dt><dd><p>Checks the types of the provided arguments. Supports unary and binary predicates.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="pycypher.node_classes.Predicate.argument_types">
<span class="sig-name descname"><span class="pre">argument_types</span></span><a class="headerlink" href="#pycypher.node_classes.Predicate.argument_types" title="Link to this definition"></a></dt>
<dd><p>alias of <a class="reference external" href="https://docs.python.org/3/library/typing.html#typing.Any" title="(in Python v3.13)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Any</span></code></a></p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pycypher.node_classes.Predicate.children">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">children</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">Generator</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="index.html#pycypher.tree_mixin.TreeMixin" title="pycypher.tree_mixin.TreeMixin"><span class="pre">TreeMixin</span></a><span class="p"><span class="pre">]</span></span></em><a class="headerlink" href="#pycypher.node_classes.Predicate.children" title="Link to this definition"></a></dt>
<dd><p>Each node should have a children property that returns a generator of its children.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pycypher.node_classes.Predicate.left_side_types">
<span class="sig-name descname"><span class="pre">left_side_types</span></span><a class="headerlink" href="#pycypher.node_classes.Predicate.left_side_types" title="Link to this definition"></a></dt>
<dd><p>alias of <a class="reference external" href="https://docs.python.org/3/library/typing.html#typing.Any" title="(in Python v3.13)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Any</span></code></a></p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pycypher.node_classes.Predicate.right_side_types">
<span class="sig-name descname"><span class="pre">right_side_types</span></span><a class="headerlink" href="#pycypher.node_classes.Predicate.right_side_types" title="Link to this definition"></a></dt>
<dd><p>alias of <a class="reference external" href="https://docs.python.org/3/library/typing.html#typing.Any" title="(in Python v3.13)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Any</span></code></a></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pycypher.node_classes.Predicate.type_check">
<span class="sig-name descname"><span class="pre">type_check</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pycypher.node_classes.Predicate.type_check" title="Link to this definition"></a></dt>
<dd><p>Perform type checking on the provided arguments.
This method processes the provided arguments, replacing instances of the
<cite>Literal</cite> class with their <cite>value</cite> attribute. It then performs type checking
based on the number of arguments provided.
Args:</p>
<blockquote>
<div><p><a href="#id11"><span class="problematic" id="id12">*</span></a>args: Variable length argument list. Can be one or two arguments.</p>
</div></blockquote>
<dl class="simple">
<dt>Raises:</dt><dd><p>ValueError: If the number of arguments is not one or two.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pycypher.node_classes.Projection">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pycypher.node_classes.</span></span><span class="sig-name descname"><span class="pre">Projection</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">lookups</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3/library/typing.html#typing.List" title="(in Python v3.13)"><span class="pre">List</span></a><span class="p"><span class="pre">[</span></span><a class="reference internal" href="index.html#pycypher.node_classes.ObjectAttributeLookup" title="pycypher.node_classes.ObjectAttributeLookup"><span class="pre">ObjectAttributeLookup</span></a><span class="p"><span class="pre">]</span></span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><a class="reference external" href="https://docs.python.org/3/library/constants.html#None" title="(in Python v3.13)"><span class="pre">None</span></a></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pycypher.node_classes.Projection" title="Link to this definition"></a></dt>
<dd><p>A class representing a projection in a tree structure.</p>
<dl class="simple">
<dt>Attributes:</dt><dd><p>lookups (List[ObjectAttributeLookup]): A list of ObjectAttributeLookup instances.</p>
</dd>
<dt>Methods:</dt><dd><p>__repr__(): Returns a string representation of the Projection instance.
tree(): Constructs and returns a Tree representation of the Projection instance.
children(): A generator that yields the lookups.</p>
</dd>
</dl>
<dl class="py property">
<dt class="sig sig-object py" id="pycypher.node_classes.Projection.children">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">children</span></span><a class="headerlink" href="#pycypher.node_classes.Projection.children" title="Link to this definition"></a></dt>
<dd><p>Each node should have a children property that returns a generator of its children.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pycypher.node_classes.Projection.tree">
<span class="sig-name descname"><span class="pre">tree</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pycypher.node_classes.Projection.tree" title="Link to this definition"></a></dt>
<dd><p>Generates a tree representation of the AST which can be pretty-printed
with the <code class="docutils literal notranslate"><span class="pre">rich</span></code> library.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pycypher.node_classes.Query">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pycypher.node_classes.</span></span><span class="sig-name descname"><span class="pre">Query</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">match_clause</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="index.html#pycypher.node_classes.Match" title="pycypher.node_classes.Match"><span class="pre">Match</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_clause</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="index.html#pycypher.node_classes.Return" title="pycypher.node_classes.Return"><span class="pre">Return</span></a></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pycypher.node_classes.Query" title="Link to this definition"></a></dt>
<dd><p>Represents a Cypher query consisting of a MATCH clause and a RETURN clause.</p>
<dl class="simple">
<dt>Attributes:</dt><dd><p>match_clause (Match): The MATCH clause of the query.
return_clause (Return): The RETURN clause of the query.</p>
</dd>
<dt>Methods:</dt><dd><p>children: A generator that yields the match_clause and return_clause.
__repr__: Returns a string representation of the Query object.
tree: Constructs and returns a Tree representation of the Query object.</p>
</dd>
</dl>
<dl class="py property">
<dt class="sig sig-object py" id="pycypher.node_classes.Query.children">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">children</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">Generator</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="index.html#pycypher.node_classes.Match" title="pycypher.node_classes.Match"><span class="pre">Match</span></a><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><a class="reference internal" href="index.html#pycypher.node_classes.Return" title="pycypher.node_classes.Return"><span class="pre">Return</span></a><span class="p"><span class="pre">]</span></span></em><a class="headerlink" href="#pycypher.node_classes.Query.children" title="Link to this definition"></a></dt>
<dd><p>Each node should have a children property that returns a generator of its children.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pycypher.node_classes.Query.tree">
<span class="sig-name descname"><span class="pre">tree</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Tree</span></span></span><a class="headerlink" href="#pycypher.node_classes.Query.tree" title="Link to this definition"></a></dt>
<dd><p>Generates a tree representation of the AST which can be pretty-printed
with the <code class="docutils literal notranslate"><span class="pre">rich</span></code> library.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pycypher.node_classes.Relationship">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pycypher.node_classes.</span></span><span class="sig-name descname"><span class="pre">Relationship</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name_label</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="index.html#pycypher.node_classes.NodeNameLabel" title="pycypher.node_classes.NodeNameLabel"><span class="pre">NodeNameLabel</span></a></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pycypher.node_classes.Relationship" title="Link to this definition"></a></dt>
<dd><p>Relationships may contain a variable name, label, or mapping.</p>
<dl class="py property">
<dt class="sig sig-object py" id="pycypher.node_classes.Relationship.children">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">children</span></span><a class="headerlink" href="#pycypher.node_classes.Relationship.children" title="Link to this definition"></a></dt>
<dd><p>Each node should have a children property that returns a generator of its children.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pycypher.node_classes.Relationship.tree">
<span class="sig-name descname"><span class="pre">tree</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pycypher.node_classes.Relationship.tree" title="Link to this definition"></a></dt>
<dd><p>Generates a tree representation of the AST which can be pretty-printed
with the <code class="docutils literal notranslate"><span class="pre">rich</span></code> library.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pycypher.node_classes.RelationshipChain">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pycypher.node_classes.</span></span><span class="sig-name descname"><span class="pre">RelationshipChain</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">steps</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3/library/typing.html#typing.List" title="(in Python v3.13)"><span class="pre">List</span></a><span class="p"><span class="pre">[</span></span><a class="reference internal" href="index.html#pycypher.tree_mixin.TreeMixin" title="pycypher.tree_mixin.TreeMixin"><span class="pre">TreeMixin</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pycypher.node_classes.RelationshipChain" title="Link to this definition"></a></dt>
<dd><p>Several <code class="docutils literal notranslate"><span class="pre">Relationship</span></code> nodes chained together, sharing <code class="docutils literal notranslate"><span class="pre">Node</span></code> objects
between them.</p>
<dl class="py property">
<dt class="sig sig-object py" id="pycypher.node_classes.RelationshipChain.children">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">children</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">Generator</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="index.html#pycypher.tree_mixin.TreeMixin" title="pycypher.tree_mixin.TreeMixin"><span class="pre">TreeMixin</span></a><span class="p"><span class="pre">]</span></span></em><a class="headerlink" href="#pycypher.node_classes.RelationshipChain.children" title="Link to this definition"></a></dt>
<dd><p>Each node should have a children property that returns a generator of its children.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pycypher.node_classes.RelationshipChain.tree">
<span class="sig-name descname"><span class="pre">tree</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Tree</span></span></span><a class="headerlink" href="#pycypher.node_classes.RelationshipChain.tree" title="Link to this definition"></a></dt>
<dd><p>Generates a tree representation of the AST which can be pretty-printed
with the <code class="docutils literal notranslate"><span class="pre">rich</span></code> library.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pycypher.node_classes.RelationshipChainList">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pycypher.node_classes.</span></span><span class="sig-name descname"><span class="pre">RelationshipChainList</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">relationships</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3/library/typing.html#typing.List" title="(in Python v3.13)"><span class="pre">List</span></a><span class="p"><span class="pre">[</span></span><a class="reference internal" href="index.html#pycypher.node_classes.RelationshipChain" title="pycypher.node_classes.RelationshipChain"><span class="pre">RelationshipChain</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pycypher.node_classes.RelationshipChainList" title="Link to this definition"></a></dt>
<dd><p>A class to represent a list of relationship chains.</p>
<section id="attributes">
<h6>Attributes:<a class="headerlink" href="#attributes" title="Link to this heading"></a></h6>
<dl class="simple">
<dt>relationships<span class="classifier">List[RelationshipChain]</span></dt><dd><p>A list of RelationshipChain objects.</p>
</dd>
</dl>
</section>
<section id="id13">
<h6>Methods:<a class="headerlink" href="#id13" title="Link to this heading"></a></h6>
<dl class="simple">
<dt>__repr__():</dt><dd><p>Returns a string representation of the RelationshipChainList object.</p>
</dd>
<dt>tree() -&gt; Tree:</dt><dd><p>Constructs and returns a Tree representation of the RelationshipChainList.</p>
</dd>
<dt>children() -&gt; Generator[RelationshipChain]:</dt><dd><p>A generator that yields the RelationshipChain objects in the list.</p>
</dd>
</dl>
<dl class="py property">
<dt class="sig sig-object py" id="pycypher.node_classes.RelationshipChainList.children">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">children</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">Generator</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="index.html#pycypher.node_classes.RelationshipChain" title="pycypher.node_classes.RelationshipChain"><span class="pre">RelationshipChain</span></a><span class="p"><span class="pre">]</span></span></em><a class="headerlink" href="#pycypher.node_classes.RelationshipChainList.children" title="Link to this definition"></a></dt>
<dd><p>Each node should have a children property that returns a generator of its children.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pycypher.node_classes.RelationshipChainList.tree">
<span class="sig-name descname"><span class="pre">tree</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Tree</span></span></span><a class="headerlink" href="#pycypher.node_classes.RelationshipChainList.tree" title="Link to this definition"></a></dt>
<dd><p>Generates a tree representation of the AST which can be pretty-printed
with the <code class="docutils literal notranslate"><span class="pre">rich</span></code> library.</p>
</dd></dl>

</section>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pycypher.node_classes.RelationshipLeftRight">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pycypher.node_classes.</span></span><span class="sig-name descname"><span class="pre">RelationshipLeftRight</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">relationship</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="index.html#pycypher.node_classes.Relationship" title="pycypher.node_classes.Relationship"><span class="pre">Relationship</span></a></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pycypher.node_classes.RelationshipLeftRight" title="Link to this definition"></a></dt>
<dd><p>A <code class="docutils literal notranslate"><span class="pre">Relationship</span></code> with the arrow pointing from left to right. Note that there
is no semantic difference between this and <code class="docutils literal notranslate"><span class="pre">RelationshipRightLeft</span></code>.</p>
<dl class="py property">
<dt class="sig sig-object py" id="pycypher.node_classes.RelationshipLeftRight.children">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">children</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">Generator</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="index.html#pycypher.node_classes.Relationship" title="pycypher.node_classes.Relationship"><span class="pre">Relationship</span></a><span class="p"><span class="pre">]</span></span></em><a class="headerlink" href="#pycypher.node_classes.RelationshipLeftRight.children" title="Link to this definition"></a></dt>
<dd><p>Each node should have a children property that returns a generator of its children.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pycypher.node_classes.RelationshipLeftRight.constraints">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">constraints</span></span><a class="headerlink" href="#pycypher.node_classes.RelationshipLeftRight.constraints" title="Link to this definition"></a></dt>
<dd><p>Calculates the <code class="docutils literal notranslate"><span class="pre">Constraint</span></code> objects for this <code class="docutils literal notranslate"><span class="pre">Relationship</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pycypher.node_classes.RelationshipLeftRight.tree">
<span class="sig-name descname"><span class="pre">tree</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Tree</span></span></span><a class="headerlink" href="#pycypher.node_classes.RelationshipLeftRight.tree" title="Link to this definition"></a></dt>
<dd><p>Generates a tree representation of the AST which can be pretty-printed
with the <code class="docutils literal notranslate"><span class="pre">rich</span></code> library.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pycypher.node_classes.RelationshipRightLeft">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pycypher.node_classes.</span></span><span class="sig-name descname"><span class="pre">RelationshipRightLeft</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">relationship</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="index.html#pycypher.node_classes.Relationship" title="pycypher.node_classes.Relationship"><span class="pre">Relationship</span></a></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pycypher.node_classes.RelationshipRightLeft" title="Link to this definition"></a></dt>
<dd><p>A <code class="docutils literal notranslate"><span class="pre">Relationship</span></code> with the arrow pointing from right to left. Note that there
is no semantic difference between this and <code class="docutils literal notranslate"><span class="pre">RelationshipLeftRight</span></code>.</p>
<dl class="py property">
<dt class="sig sig-object py" id="pycypher.node_classes.RelationshipRightLeft.children">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">children</span></span><a class="headerlink" href="#pycypher.node_classes.RelationshipRightLeft.children" title="Link to this definition"></a></dt>
<dd><p>Each node should have a children property that returns a generator of its children.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pycypher.node_classes.RelationshipRightLeft.tree">
<span class="sig-name descname"><span class="pre">tree</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pycypher.node_classes.RelationshipRightLeft.tree" title="Link to this definition"></a></dt>
<dd><p>Generates a tree representation of the AST which can be pretty-printed
with the <code class="docutils literal notranslate"><span class="pre">rich</span></code> library.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pycypher.node_classes.Return">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pycypher.node_classes.</span></span><span class="sig-name descname"><span class="pre">Return</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">node</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="index.html#pycypher.node_classes.Projection" title="pycypher.node_classes.Projection"><span class="pre">Projection</span></a></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pycypher.node_classes.Return" title="Link to this definition"></a></dt>
<dd><p>The Return class represents a RETURN clause in a Cypher query. It is used to specify
which projections (columns) should be returned from the query.</p>
<dl>
<dt>Attributes:</dt><dd><p>projection (Projection): The projection node that specifies the columns to be returned.</p>
</dd>
<dt>Methods:</dt><dd><p>__repr__(): Returns a string representation of the Return object.
tree(): Returns a tree representation of the Return object.
children(): Yields the child nodes of the Return object.
_evaluate(fact_collection, projection=None): Evaluates the RETURN clause and returns</p>
<blockquote>
<div><p>the specified projections from the WITH clause.</p>
</div></blockquote>
</dd>
</dl>
<dl class="py property">
<dt class="sig sig-object py" id="pycypher.node_classes.Return.children">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">children</span></span><a class="headerlink" href="#pycypher.node_classes.Return.children" title="Link to this definition"></a></dt>
<dd><p>Each node should have a children property that returns a generator of its children.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pycypher.node_classes.Return.tree">
<span class="sig-name descname"><span class="pre">tree</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pycypher.node_classes.Return.tree" title="Link to this definition"></a></dt>
<dd><p>Generates a tree representation of the AST which can be pretty-printed
with the <code class="docutils literal notranslate"><span class="pre">rich</span></code> library.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pycypher.node_classes.Size">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pycypher.node_classes.</span></span><span class="sig-name descname"><span class="pre">Size</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">collection</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="index.html#pycypher.node_classes.Collection" title="pycypher.node_classes.Collection"><span class="pre">Collection</span></a></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pycypher.node_classes.Size" title="Link to this definition"></a></dt>
<dd><p>Represents a size operation on a collection, like a <code class="docutils literal notranslate"><span class="pre">len</span></code> in Python.</p>
<dl>
<dt>Attributes:</dt><dd><p>collection (Collection): The collection whose size is to be evaluated.</p>
</dd>
<dt>Methods:</dt><dd><dl>
<dt>children:</dt><dd><p>Yields the collection as the child node.</p>
</dd>
<dt>__repr__:</dt><dd><p>Returns a string representation of the Size instance.</p>
</dd>
<dt>tree:</dt><dd><p>Constructs and returns a tree representation of the Size instance.</p>
</dd>
<dt>_evaluate:</dt><dd><p>Evaluates the size of the collection within the given fact collection and projection context.
Args:</p>
<blockquote>
<div><p>fact_collection (FactCollection): The collection of facts to evaluate against.
projection (Optional[Dict[str, str | List[str]]]): The projection context for evaluation.</p>
</div></blockquote>
<dl class="simple">
<dt>Returns:</dt><dd><p>Literal: The size of the collection as a Literal instance.</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
<dl class="py property">
<dt class="sig sig-object py" id="pycypher.node_classes.Size.children">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">children</span></span><a class="headerlink" href="#pycypher.node_classes.Size.children" title="Link to this definition"></a></dt>
<dd><p>Each node should have a children property that returns a generator of its children.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pycypher.node_classes.Size.tree">
<span class="sig-name descname"><span class="pre">tree</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pycypher.node_classes.Size.tree" title="Link to this definition"></a></dt>
<dd><p>Generates a tree representation of the AST which can be pretty-printed
with the <code class="docutils literal notranslate"><span class="pre">rich</span></code> library.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pycypher.node_classes.Subtraction">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pycypher.node_classes.</span></span><span class="sig-name descname"><span class="pre">Subtraction</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">left_side</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="index.html#pycypher.tree_mixin.TreeMixin" title="pycypher.tree_mixin.TreeMixin"><span class="pre">TreeMixin</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">right_side</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="index.html#pycypher.tree_mixin.TreeMixin" title="pycypher.tree_mixin.TreeMixin"><span class="pre">TreeMixin</span></a></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pycypher.node_classes.Subtraction" title="Link to this definition"></a></dt>
<dd><dl class="py method">
<dt class="sig sig-object py" id="pycypher.node_classes.Subtraction.tree">
<span class="sig-name descname"><span class="pre">tree</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Tree</span></span></span><a class="headerlink" href="#pycypher.node_classes.Subtraction.tree" title="Link to this definition"></a></dt>
<dd><p>Generates a tree representation of the AST which can be pretty-printed
with the <code class="docutils literal notranslate"><span class="pre">rich</span></code> library.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pycypher.node_classes.Where">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pycypher.node_classes.</span></span><span class="sig-name descname"><span class="pre">Where</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">predicate</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="index.html#pycypher.node_classes.Predicate" title="pycypher.node_classes.Predicate"><span class="pre">Predicate</span></a></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pycypher.node_classes.Where" title="Link to this definition"></a></dt>
<dd><dl class="py property">
<dt class="sig sig-object py" id="pycypher.node_classes.Where.children">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">children</span></span><a class="headerlink" href="#pycypher.node_classes.Where.children" title="Link to this definition"></a></dt>
<dd><p>Each node should have a children property that returns a generator of its children.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pycypher.node_classes.Where.tree">
<span class="sig-name descname"><span class="pre">tree</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Tree</span></span></span><a class="headerlink" href="#pycypher.node_classes.Where.tree" title="Link to this definition"></a></dt>
<dd><p>Generates a tree representation of the AST which can be pretty-printed
with the <code class="docutils literal notranslate"><span class="pre">rich</span></code> library.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pycypher.node_classes.WithClause">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pycypher.node_classes.</span></span><span class="sig-name descname"><span class="pre">WithClause</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">object_as_series</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="index.html#pycypher.node_classes.ObjectAsSeries" title="pycypher.node_classes.ObjectAsSeries"><span class="pre">ObjectAsSeries</span></a></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pycypher.node_classes.WithClause" title="Link to this definition"></a></dt>
<dd><p>Represents a WITH clause in a query, which is used to manage projections and aggregations.</p>
<dl class="simple">
<dt>Attributes:</dt><dd><p>object_as_series (ObjectAsSeries): The object representing the series of projections.</p>
</dd>
<dt>Methods:</dt><dd><dl class="simple">
<dt>__repr__():</dt><dd><p>Returns a string representation of the WithClause instance.</p>
</dd>
<dt>tree() -&gt; Tree:</dt><dd><p>Returns a tree representation of the WithClause.</p>
</dd>
<dt>children() -&gt; Generator[Projection]:</dt><dd><p>Yields the children projections of the WithClause.</p>
</dd>
<dt>aggregated_variables():</dt><dd><p>Returns a list of variables that are aggregated in the WithClause.</p>
</dd>
<dt>all_variables():</dt><dd><p>Returns a list of all variables in the WithClause.</p>
</dd>
<dt>non_aggregated_variables():</dt><dd><p>Returns a list of variables that are not aggregated in the WithClause.</p>
</dd>
<dt>_unique_non_aggregated_variable_solutions(solutions, non_aggregated_variables):</dt><dd><p>Returns a list of unique non-aggregated variable solutions from the given solutions.</p>
</dd>
<dt>_transform_solutions_by_aggregations(solutions, aggregated_variables, non_aggregated_variables):</dt><dd><p>Transforms the given solutions by aggregating the variables.</p>
</dd>
<dt>transform_solutions_by_aggregations(fact_collection: FactCollection):</dt><dd><p>Transforms the solutions from the parent by aggregating the variables.</p>
</dd>
<dt>_evaluate_one_projection(fact_collection: FactCollection, projection: Optional[Dict[str, str | List[str]]] = None) -&gt; Any:</dt><dd><p>Evaluates a single projection within the fact collection.</p>
</dd>
<dt>_evaluate(fact_collection: FactCollection, projection: Optional[Any] = None):</dt><dd><p>Evaluates the WithClause within the fact collection and returns the result.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="py property">
<dt class="sig sig-object py" id="pycypher.node_classes.WithClause.children">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">children</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">Generator</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="index.html#pycypher.node_classes.Projection" title="pycypher.node_classes.Projection"><span class="pre">Projection</span></a><span class="p"><span class="pre">]</span></span></em><a class="headerlink" href="#pycypher.node_classes.WithClause.children" title="Link to this definition"></a></dt>
<dd><p>Each node should have a children property that returns a generator of its children.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pycypher.node_classes.WithClause.tree">
<span class="sig-name descname"><span class="pre">tree</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Tree</span></span></span><a class="headerlink" href="#pycypher.node_classes.WithClause.tree" title="Link to this definition"></a></dt>
<dd><p>Generates a tree representation of the AST which can be pretty-printed
with the <code class="docutils literal notranslate"><span class="pre">rich</span></code> library.</p>
</dd></dl>

</dd></dl>

</section>
<span id="document-generated/pycypher.shim"></span><section id="shims">
<h5>Shims<a class="headerlink" href="#shims" title="Link to this heading"></a></h5>
<p>In order to use <cite>pycypher</cite> as a search engine (as opposed to just using it to parse Cypher into an AST), you need to have a subclass of <code class="docutils literal notranslate"><span class="pre">Shim</span></code> appropriate for your data source.</p>
<p>The job of a <code class="docutils literal notranslate"><span class="pre">Shim</span></code> is to generate a <code class="docutils literal notranslate"><span class="pre">FactCollection</span></code> object from your data source. When you call <code class="docutils literal notranslate"><span class="pre">CypherParser.solutions</span></code> on your shim, it will automatically generate the required <code class="docutils literal notranslate"><span class="pre">FactCollection</span></code> and return the solution(s) to your query.</p>
<p><code class="docutils literal notranslate"><span class="pre">Shim</span></code> is a very simple abstract base class that requires you to implement a single method, <code class="docutils literal notranslate"><span class="pre">make_fact_collection</span></code>. This method should return a <code class="docutils literal notranslate"><span class="pre">FactCollection</span></code> object. For reference, we include a shim for NetworkX’s <code class="docutils literal notranslate"><span class="pre">DiGraph</span></code> (directed graph) class, which is documented in detail. But generally speaking, there is a standard strategy for implementing your <code class="docutils literal notranslate"><span class="pre">make_fact_collection</span></code> method, which goes like this:</p>
<ol class="arabic simple">
<li><p>Make a new <code class="docutils literal notranslate"><span class="pre">FactCollection</span></code> object.</p></li>
<li><dl class="simple">
<dt>Traverse your graph, and:</dt><dd><ul class="simple">
<li><dl class="simple">
<dt>for each node:</dt><dd><ul>
<li><p>if it has a label, create a <code class="docutils literal notranslate"><span class="pre">FactNodeHasLabel</span></code> object, initialized with the node’s ID and label;</p></li>
<li><p>if it has any attributes, create a <code class="docutils literal notranslate"><span class="pre">FactNodeHasProperty</span></code> object for each attribute, initialized with the node’s ID, attribute name, and attribute value.</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>for each edge:</dt><dd><ul>
<li><p>if it has a label, create a <code class="docutils literal notranslate"><span class="pre">FactRelationshipHasLabel</span></code> object, initialized with the edge’s ID and label;</p></li>
<li><p>if it has any attributes, create a <code class="docutils literal notranslate"><span class="pre">FactRelationshipHasAttribute</span></code> object for each attribute, initialized with the edge’s ID, attribute name, and attribute value;</p></li>
<li><p>create a <code class="docutils literal notranslate"><span class="pre">FactEdgeHasSourceNode</span></code> object, initialized with the edge’s ID and source node ID;</p></li>
<li><p>create a <code class="docutils literal notranslate"><span class="pre">FactEdgeHasTargetNode</span></code> object, initialized with the edge’s ID and target node ID.</p></li>
</ul>
</dd>
</dl>
</li>
<li><p>Add those facts to your <code class="docutils literal notranslate"><span class="pre">FactCollection</span></code> object.</p></li>
</ul>
</dd>
</dl>
</li>
<li><p>Return the <code class="docutils literal notranslate"><span class="pre">FactCollection</span></code> object.</p></li>
</ol>
<p>The NetworkX shim is an example of this procedure. It inherits from <code class="docutils literal notranslate"><span class="pre">Shim</span></code>, takes a <code class="docutils literal notranslate"><span class="pre">networkx.DiGraph</span></code> object in its <code class="docutils literal notranslate"><span class="pre">__init__</span></code> method, and implements the <code class="docutils literal notranslate"><span class="pre">make_fact_collection</span></code> method. That method traverses the graph, defining a list of <code class="docutils literal notranslate"><span class="pre">Fact</span></code> objects. Then it adds those <code class="docutils literal notranslate"><span class="pre">Fact</span></code> objects to a <code class="docutils literal notranslate"><span class="pre">FactCollection</span></code>.</p>
<p>If you follow this procedure, you should be able to call <code class="docutils literal notranslate"><span class="pre">CypherParser.solutions</span></code> on your shim and get the results you expect.</p>
<p id="module-pycypher.shims">Abstract base class</p>
<p class="rubric">Functions</p>
<table class="autosummary longtable docutils align-default">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#pycypher.shims.Shim" title="pycypher.shims.Shim"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Shim</span></code></a>(*args, **kwargs)</p></td>
<td><p>Abstract base class for interfaces between data structures and the Cypher query language.</p></td>
</tr>
</tbody>
</table>
<dl class="py class">
<dt class="sig sig-object py" id="pycypher.shims.Shim">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pycypher.shims.</span></span><span class="sig-name descname"><span class="pre">Shim</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pycypher.shims.Shim" title="Link to this definition"></a></dt>
<dd><p>Abstract base class for interfaces between data structures and
the Cypher query language.</p>
<dl class="py method">
<dt class="sig sig-object py" id="pycypher.shims.Shim.make_fact_collection">
<em class="property"><span class="pre">abstract</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">make_fact_collection</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pycypher.shims.Shim.make_fact_collection" title="Link to this definition"></a></dt>
<dd><p>Overridden</p>
</dd></dl>

</dd></dl>

</section>
<span id="document-generated/pycypher.solver"></span><section id="module-pycypher.solver">
<span id="constraint-solver"></span><h5>Constraint Solver<a class="headerlink" href="#module-pycypher.solver" title="Link to this heading"></a></h5>
<p class="rubric">Classes</p>
<table class="autosummary longtable docutils align-default">
<tbody>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">Constraint</span></code>()</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">ConstraintNodeHasAttributeWithValue</span></code>(node_id, ...)</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#pycypher.solver.ConstraintNodeHasLabel" title="pycypher.solver.ConstraintNodeHasLabel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ConstraintNodeHasLabel</span></code></a>(node_id, label)</p></td>
<td><p>Node has a label</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#pycypher.solver.IsTrue" title="pycypher.solver.IsTrue"><code class="xref py py-obj docutils literal notranslate"><span class="pre">IsTrue</span></code></a>(predicate)</p></td>
<td><p>Class to represent a constraint that merely says that a <code class="docutils literal notranslate"><span class="pre">Predicate</span></code> is true.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">State</span></code>()</p></td>
<td><p></p></td>
</tr>
</tbody>
</table>
<dl class="py class">
<dt class="sig sig-object py" id="pycypher.solver.ConstraintNodeHasLabel">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pycypher.solver.</span></span><span class="sig-name descname"><span class="pre">ConstraintNodeHasLabel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">node_id</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.13)"><span class="pre">str</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">label</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.13)"><span class="pre">str</span></a></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pycypher.solver.ConstraintNodeHasLabel" title="Link to this definition"></a></dt>
<dd><p>Node has a label</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pycypher.solver.IsTrue">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pycypher.solver.</span></span><span class="sig-name descname"><span class="pre">IsTrue</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">predicate</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="index.html#pycypher.node_classes.Predicate" title="pycypher.node_classes.Predicate"><span class="pre">Predicate</span></a></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pycypher.solver.IsTrue" title="Link to this definition"></a></dt>
<dd><p>Class to represent a constraint that merely says that a <code class="docutils literal notranslate"><span class="pre">Predicate</span></code> is true.</p>
</dd></dl>

</section>
<span id="document-generated/pycypher.tree_mixin"></span><section id="module-pycypher.tree_mixin">
<span id="tree-mixin"></span><h5>Tree Mixin<a class="headerlink" href="#module-pycypher.tree_mixin" title="Link to this heading"></a></h5>
<p>This is a mixin class that provides methods for walking and printing
the AST.</p>
<p class="rubric">Classes</p>
<table class="autosummary longtable docutils align-default">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#pycypher.tree_mixin.TreeMixin" title="pycypher.tree_mixin.TreeMixin"><code class="xref py py-obj docutils literal notranslate"><span class="pre">TreeMixin</span></code></a>()</p></td>
<td><p>Mixin class that provides methods for walking and printing the AST.</p></td>
</tr>
</tbody>
</table>
<dl class="py class">
<dt class="sig sig-object py" id="pycypher.tree_mixin.TreeMixin">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pycypher.tree_mixin.</span></span><span class="sig-name descname"><span class="pre">TreeMixin</span></span><a class="headerlink" href="#pycypher.tree_mixin.TreeMixin" title="Link to this definition"></a></dt>
<dd><p>Mixin class that provides methods for walking and printing the AST.</p>
<dl class="py property">
<dt class="sig sig-object py" id="pycypher.tree_mixin.TreeMixin.children">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">children</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">Generator</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="index.html#pycypher.tree_mixin.TreeMixin" title="pycypher.tree_mixin.TreeMixin"><span class="pre">TreeMixin</span></a><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.13)"><span class="pre">str</span></a><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><a class="reference external" href="https://docs.python.org/3/library/constants.html#None" title="(in Python v3.13)"><span class="pre">None</span></a><span class="p"><span class="pre">]</span></span></em><a class="headerlink" href="#pycypher.tree_mixin.TreeMixin.children" title="Link to this definition"></a></dt>
<dd><p>Each node should have a children property that returns a generator of its children.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pycypher.tree_mixin.TreeMixin.enclosing_class">
<span class="sig-name descname"><span class="pre">enclosing_class</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cls</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3/library/typing.html#typing.Type" title="(in Python v3.13)"><span class="pre">Type</span></a><span class="p"><span class="pre">[</span></span><a class="reference internal" href="index.html#pycypher.tree_mixin.TreeMixin" title="pycypher.tree_mixin.TreeMixin"><span class="pre">TreeMixin</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="index.html#pycypher.tree_mixin.TreeMixin" title="pycypher.tree_mixin.TreeMixin"><span class="pre">TreeMixin</span></a></span></span><a class="headerlink" href="#pycypher.tree_mixin.TreeMixin.enclosing_class" title="Link to this definition"></a></dt>
<dd><p>Returns the first enclosing node of the given class.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pycypher.tree_mixin.TreeMixin.parse_obj">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">parse_obj</span></span><a class="headerlink" href="#pycypher.tree_mixin.TreeMixin.parse_obj" title="Link to this definition"></a></dt>
<dd><p>Returns the parse object thst contains the AST and other stuff.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pycypher.tree_mixin.TreeMixin.print_tree">
<span class="sig-name descname"><span class="pre">print_tree</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pycypher.tree_mixin.TreeMixin.print_tree" title="Link to this definition"></a></dt>
<dd><p>Uses <code class="docutils literal notranslate"><span class="pre">rich</span></code> to print the tree representation of the AST.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pycypher.tree_mixin.TreeMixin.root">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">root</span></span><a class="headerlink" href="#pycypher.tree_mixin.TreeMixin.root" title="Link to this definition"></a></dt>
<dd><p>Returns the root node of the AST.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pycypher.tree_mixin.TreeMixin.tree">
<em class="property"><span class="pre">abstract</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">tree</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Tree</span></span></span><a class="headerlink" href="#pycypher.tree_mixin.TreeMixin.tree" title="Link to this definition"></a></dt>
<dd><p>Generates a tree representation of the AST which can be pretty-printed
with the <code class="docutils literal notranslate"><span class="pre">rich</span></code> library.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pycypher.tree_mixin.TreeMixin.walk">
<span class="sig-name descname"><span class="pre">walk</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Generator</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="index.html#pycypher.tree_mixin.TreeMixin" title="pycypher.tree_mixin.TreeMixin"><span class="pre">TreeMixin</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pycypher.tree_mixin.TreeMixin.walk" title="Link to this definition"></a></dt>
<dd><p>Generator that yields every node of the AST.</p>
<p>Note that this will <strong>not</strong> work if there is a list directly inside another list.
But that shouldn’t happen in an AST anyway.</p>
</dd></dl>

</dd></dl>

</section>
</div>
</section>
</div>
</section>
</section>
</section>


           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2024, Zachary Ernst.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>